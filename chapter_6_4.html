<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rendering Static Screen - Writing NES Emulator in Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Writing NES Emulator in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rendering-static-screen"><a class="header" href="#rendering-static-screen">Rendering Static Screen</a></h1>
<p>At this point, the CPU and PPU are fully functional and working in coordination with each other.
If we were to load a game into our emulator, the game would execute and most likely run into demo mode.</p>
<p>The problem is that we can't see what's going on inside. Remember how we had intercepted the execution of the snake game to read the game screen state? And then had it rendered via SDL2 canvas? We will have to do something similar here. It's just the data format used by NES is slightly more complicated.</p>
<p>PPU has to deal with 2 categories of objects:</p>
<div style="text-align:center"><img src="./images/ch6.4/image_8_bg_sprites_game.png" width="80%"/></div>
<p>Both of those are constructed using CHR tiles, we've discussed in the previous chapter.
In fact, the same tiles can be used both for background and for sprites.</p>
<p>NES uses different memory spaces to hold those categories. The set of possible transformations is also different.</p>
<h2 id="rendering-background"><a class="header" href="#rendering-background">Rendering Background</a></h2>
<!-- <div style="text-align:center"><img src="./images/ch6.4/image_1_pacman_bg.png" width="30%"/></div> -->
<p>Three main memory sections are responsible for the state of a background:</p>
<ul>
<li>Pattern Table - one of 2 banks of tiles from CHR ROM</li>
<li>Nametable - the state of a screen stored in VRAM</li>
<li>Palette table - the information about the real coloring of pixels, stored in internal PPU memory</li>
</ul>
<p>NES Screen background screen is composed of 960 tiles (a tile being 8x8 pixels: <code>256 / 8 * 240 / 8 = 960</code>)
Each tile is represented by one byte in VRAM in the space called Nametable.</p>
<div style="text-align:center"><img src="./images/ch6.4/image_2_nametable.png" width="100%"/></div>
<blockquote>
<p>Using a byte in nametable PPU can address only 256 elements within a single bank in pattern table.
Control register decides which of two banks should be used for background (and which one should be used for sprites).</p>
<div style="text-align:left"><img src="./images/ch6.4/image_3_control_register_highlight.png" width="50%"/></div>
</blockquote>
<p>In addition to 960 bytes for tiles, a nametable holds 64 bytes that specify color palette, we will discuss later. In total, a single frame is defined as 1024 bytes (960 + 64). PPU VRAM can simultaneously hold two nametables - the states of two frames.</p>
<p>Two additional nametables that exist in the address space of the PPU must be either mapped to existing tables or to extra RAM space on a cartridge.
<a href="http://wiki.nesdev.com/w/index.php/Mirroring">More details</a>.</p>
<p>Nametables are populated by CPU during program execution (using Addr and Data registers that we've implemented). It's entirely determined by game code. All we need to do is to read the correct part of the VRAM.</p>
<p>The algorithm to draw current background:</p>
<ol>
<li>Determine which nametable is being used for the current screen (by reading bit 0 and bit 1 from Control register)</li>
<li>Determine which CHR ROM bank is used for background tiles (by reading bit 4 from Control Register)</li>
<li>Read 960 bytes from the specified nametable and draw a 32x30 tile-based screen</li>
</ol>
<p>Let's add <code>render</code> function to a new <code>render</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod frame;
pub mod palette;

use crate::ppu::NesPPU;
use frame::Frame;

pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {
   let bank = ppu.ctrl.bknd_pattern_addr();

   for i in 0..0x03c0 { // just for now, lets use the first nametable
       let tile = ppu.vram[i] as u16;
       let tile_x = i % 32;
       let tile_y = i / 32;
       let tile = &amp;ppu.chr_rom[(bank + tile * 16) as usize..=(bank + tile * 16 + 15) as usize];

       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];

           for x in (0..=7).rev() {
               let value = (1 &amp; upper) &lt;&lt; 1 | (1 &amp; lower);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; palette::SYSTEM_PALLETE[0x01],
                   1 =&gt; palette::SYSTEM_PALLETE[0x23],
                   2 =&gt; palette::SYSTEM_PALLETE[0x27],
                   3 =&gt; palette::SYSTEM_PALLETE[0x30],
                   _ =&gt; panic!("can't be"),
               };
               frame.set_pixel(tile_x*8 + x, tile_y*8 + y, rgb)
           }
       }
   }
}

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note: We are still using randomly picked colors from a system palette just to see shapes</p>
</blockquote>
<p>Again, we need to intercept the program execution to read the screen state.
On the real console the PPU is drawing one pixel each PPU clock cycle. However, we can take a shortcut. Instead of reading part of the screen state on each PPU clock tick, we can wait until the full screen is ready and read in one go.</p>
<blockquote>
<p><strong>WARNING</strong> This is quite a drastic simplification that limits the types of games it will be possible to play on the emulator. </br><br/>More advanced games used a lot of tricks to enrich the gaming experience.
For example, changing scroll in the middle of the frame (<a href="https://wiki.nesdev.com/w/index.php/PPU_scrolling#Split_X_scroll">split scroll</a>) or changing palette colors. <br/><br/>
This simplification wouldn't affect first-gen NES games much. The majority of NES games would require more accuracy in PPU emulation, however.</p>
</blockquote>
<p>On the real console, PPU is actively drawing screen state on a TV screen during 0 - 240 scanlines; during scanlines 241 - 262, the CPU is updating the state of PPU for the next frame, then the cycle repeats.</p>
<p>One way to intercept is to read the screen state right after NMI interrupt - when PPU is done rendering the current frame, but before CPU starts creating the next one.</p>
<p>First lets add callback to the bus, that will be called every time PPU triggers NMI:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ub struct Bus&lt;'call&gt; {
   cpu_vram: [u8; 2048],
   prg_rom: Vec&lt;u8&gt;,
   ppu: NesPPU,

   cycles: usize,
   gameloop_callback: Box&lt;dyn FnMut(&amp;NesPPU) + 'call&gt;,

}

impl&lt;'a&gt; Bus&lt;'a&gt; {
   pub fn new&lt;'call, F&gt;(rom: Rom, gameloop_callback: F) -&gt; Bus&lt;'call&gt;
   where
       F: FnMut(&amp;NesPPU) + 'call,
   {
       let ppu = NesPPU::new(rom.chr_rom, rom.screen_mirroring);

       Bus {
           cpu_vram: [0; 2048],
           prg_rom: rom.prg_rom,
           ppu: ppu,
           cycles: 0,
           gameloop_callback: Box::from(gameloop_callback),
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>Then lets tweak the <code>tick</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Bus&lt;'a&gt; {
//..
   pub fn tick(&amp;mut self, cycles: u8) {
        self.cycles += cycles as usize;

        let nmi_before = self.ppu.nmi_interrupt.is_some();
        self.ppu.tick(cycles *3);
        let nmi_after = self.ppu.nmi_interrupt.is_some();
        
        if !nmi_before &amp;&amp; nmi_after {
            (self.gameloop_callback)(&amp;self.ppu, &amp;mut self.joypad1);
        }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>Then we can connect gameloop, interrupt callback and render function:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
   // init sdl2…

   //load the game
   let bytes: Vec&lt;u8&gt; = std::fs::read("game.nes").unwrap();
   let rom = Rom::new(&amp;bytes).unwrap();

   let mut frame = Frame::new();

   // the game cycle
   let bus = Bus::new(rom, move |ppu: &amp;NesPPU| {
       render::render(ppu, &amp;mut frame);
       texture.update(None, &amp;frame.data, 256 * 3).unwrap();

       canvas.copy(&amp;texture, None, None).unwrap();

       canvas.present();
       for event in event_pump.poll_iter() {
           match event {
             Event::Quit { .. }
             | Event::KeyDown {
                 keycode: Some(Keycode::Escape),
                 ..
             } =&gt; std::process::exit(0),
             _ =&gt; { /* do nothing */ }
           }
        }
   });

   let mut cpu = CPU::new(bus);

   cpu.reset();
   cpu.run();
}</code></pre></pre>
<p>It's working! Beau·ti·ful.</p>
<div style="text-align:center"><img src="./images/ch6.4/image_4_pacman_result.png" width="30%"/></div>
<p>Now let's fix the colors.</p>
<h2 id="working-with-colors"><a class="header" href="#working-with-colors">Working with Colors</a></h2>
<p>NES Console could generate 52 different colors on a TV screen. Those colors constitute the hardwired System Palette of the console.</p>
<p>However, a single screen can use only 25 colors simultaneously: 13 background colors and 12 for sprites.</p>
<p>NES had internal memory RAM to store palette settings.
The space is divided into 8 palettes tables: 4 for background and 4 for sprites. Each palette contains three colors.
Remember that a pixel in a tile was coded using 2 bits - that's 4 possible values. 0b00 is a special one.</p>
<blockquote>
<p><strong>0b00</strong> for <em>background</em> tile means using Universal background color (stored at <strong>0x3F00</strong>).</p>
<p>For <em>sprites</em> - <strong>0b00</strong> means that the pixel is transparent</p>
</blockquote>
<div style="text-align:center"><img src="./images/ch6.4/image_5_palette_table.png" width="100%"/></div>
<p>A single tile can be drawn using only one palette from the palette table.
For background tiles, the last 64 bytes of each nametable are reserved for assigning a specific palette to a part of the background. This section is called an attribute table.</p>
<p>A byte in an attribute table controls palettes for 4 neighboring meta-tiles. (a meta-tile is a space composed of 2x2 tiles)
To say it another way, 1 byte controls which palettes are used for 4x4 tile blocks or 32x32 pixels
A byte is split into four 2-bit blocks and each block is assigning a background palette for four neighboring tiles.</p>
<div style="text-align:center"><img src="./images/ch6.4/image_6_attribute_table.png" width="70%"/></div>
<p>First let's extract the palette for a background tile specified by its row and column position on the screen:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bg_pallette(ppu: &amp;NesPPU, tile_column: usize, tile_row : usize) -&gt; [u8;4] {
   let attr_table_idx = tile_row / 4 * 8 +  tile_column / 4;
   let attr_byte = ppu.vram[0x3c0 + attr_table_idx];  // note: still using hardcoded first nametable

   let pallet_idx = match (tile_column %4 / 2, tile_row % 4 / 2) {
       (0,0) =&gt; attr_byte &amp; 0b11,
       (1,0) =&gt; (attr_byte &gt;&gt; 2) &amp; 0b11,
       (0,1) =&gt; (attr_byte &gt;&gt; 4) &amp; 0b11,
       (1,1) =&gt; (attr_byte &gt;&gt; 6) &amp; 0b11,
       (_,_) =&gt; panic!("should not happen"),
   };

   let pallete_start: usize = 1 + (pallet_idx as usize)*4;
   [ppu.palette_table[0], ppu.palette_table[pallete_start], ppu.palette_table[pallete_start+1], ppu.palette_table[pallete_start+2]]
}
<span class="boring">}</span></code></pre></pre>
<p>And just rewire our color lookup in <code>render</code> function from using randomly picked colors to the actual ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {
   let bank = ppu.ctrl.bknd_pattern_addr();

   for i in 0..0x3c0 {
       let tile = ppu.vram[i] as u16;
       let tile_column = i % 32;
       let tile_row = i / 32;
       let tile = &amp;ppu.chr_rom[(bank + tile * 16) as usize..=(bank + tile * 16 + 15) as usize];
       let palette = bg_pallette(ppu, tile_column, tile_row);

       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];

           for x in (0..=7).rev() {
               let value = (1 &amp; lower) &lt;&lt; 1 | (1 &amp; upper);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; palette::SYSTEM_PALLETE[ppu.palette_table[0] as usize],
                   1 =&gt; palette::SYSTEM_PALLETE[palette[1] as usize],
                   2 =&gt; palette::SYSTEM_PALLETE[palette[2] as usize],
                   3 =&gt; palette::SYSTEM_PALLETE[palette[3] as usize],
                   _ =&gt; panic!("can't be"),
               };
               frame.set_pixel(tile_column * 8 + x, tile_row * 8 + y, rgb)
           }
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>That's it.</p>
<h2 id="rendering-sprites"><a class="header" href="#rendering-sprites">Rendering sprites.</a></h2>
<p>Rendering sprites is somewhat similar, but a bit easier.
NES had an internal RAM for storing states of all sprites in the frame, so-called Object Attribute Memory (OAM).</p>
<p>It had 256 bytes of RAM and reserved 4 bytes for each sprite. This gives an option of having 64 tiles on a screen simultaneously (but keep in mind that a single object on a screen usually consists of at least 3-4 tiles).</p>
<p>CPU has two options for updating the OAM Table:</p>
<ul>
<li>using OAM Addr and OAM Data PPUT registers, updating one byte at a time.</li>
<li>bulk updating the whole table by transferring 256 bytes from CPU RAM using OAM DMA</li>
</ul>
<p>In comparison to background tiles, a sprite tile can be shown anywhere in a 256x240 screen. Each OAM record has 2 bytes reserved for X and Y coordinates, one byte is used to select a tile pattern from the pattern table. And the remaining byte specifies how the object should be drawn (for example, PPU can flip same tile horizontally or vertically)</p>
<p>NES Dev Wiki provides a pretty solid specification of <a href="http://wiki.nesdev.com/w/index.php/PPU_OAM">each byte in the OAM record</a></p>
<p>To render all visible sprites, we just need to scan through oam_data space and parse out every 4 bytes into a sprite:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {

//.. draw background
//draw sprites
   for i in (0..ppu.oam_data.len()).step_by(4).rev() {
       let tile_idx = ppu.oam_data[i + 1] as u16;
       let tile_x = ppu.oam_data[i + 3] as usize;
       let tile_y = ppu.oam_data[i] as usize;

       let flip_vertical = if ppu.oam_data[i + 2] &gt;&gt; 7 &amp; 1 == 1 {
           true
       } else {
           false
       };
       let flip_horizontal = if ppu.oam_data[i + 2] &gt;&gt; 6 &amp; 1 == 1 {
           true
       } else {
           false
       };
       let pallette_idx = ppu.oam_data[i + 2] &amp; 0b11;
       let sprite_palette = sprite_palette(ppu, pallette_idx);
      
       let bank: u16 = ppu.ctrl.sprt_pattern_addr();

       let tile = &amp;ppu.chr_rom[(bank + tile_idx * 16) as usize..=(bank + tile_idx * 16 + 15) as usize];


       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];
           'ololo: for x in (0..=7).rev() {
               let value = (1 &amp; lower) &lt;&lt; 1 | (1 &amp; upper);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; continue 'ololo, // skip coloring the pixel
                   1 =&gt; palette::SYSTEM_PALLETE[sprite_palette[1] as usize],
                   2 =&gt; palette::SYSTEM_PALLETE[sprite_palette[2] as usize],
                   3 =&gt; palette::SYSTEM_PALLETE[sprite_palette[3] as usize],
                   _ =&gt; panic!("can't be"),
               };
               match (flip_horizontal, flip_vertical) {
                   (false, false) =&gt; frame.set_pixel(tile_x + x, tile_y + y, rgb),
                   (true, false) =&gt; frame.set_pixel(tile_x + 7 - x, tile_y + y, rgb),
                   (false, true) =&gt; frame.set_pixel(tile_x + x, tile_y + 7 - y, rgb),
                   (true, true) =&gt; frame.set_pixel(tile_x + 7 - x, tile_y + 7 - y, rgb),
               }
           }
       }
   }
<span class="boring">}</span></code></pre></pre>
<p>The sprite palette lookup is very easy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sprite_palette(ppu: &amp;NesPPU, pallete_idx: u8) -&gt; [u8; 4] {
    let start = 0x11 + (pallete_idx * 4) as usize;
    [
        0,
        ppu.palette_table[start],
        ppu.palette_table[start + 1],
        ppu.palette_table[start + 2],
    ]
}
<span class="boring">}</span></code></pre></pre>
<div style="text-align:center"><img src="./images/ch6.4/image_7_pacman_chrs.png" width="30%"/></div>
<p>Alright. Looks better now.</p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch6.4" target="_blank">GitHub</a></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_6_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_6_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-3286054-2', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
