<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing NES Emulator in Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> NES Platform</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Emulating CPU</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_1.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter_3_2.html"><strong aria-hidden="true">3.2.</strong> Memory addressing modes</a></li><li class="chapter-item expanded "><a href="chapter_3_3.html"><strong aria-hidden="true">3.3.</strong> The rest of the instructions</a></li><li class="chapter-item expanded "><a href="chapter_3_4.html"><strong aria-hidden="true">3.4.</strong> Running our first game</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Emulating BUS</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> Cartridges</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5_1.html"><strong aria-hidden="true">5.1.</strong> Test ROM</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Emulating PPU</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_6_1.html"><strong aria-hidden="true">6.1.</strong> Emulating PPU Registers</a></li><li class="chapter-item expanded "><a href="chapter_6_2.html"><strong aria-hidden="true">6.2.</strong> Emulating NMI Interrupt</a></li><li class="chapter-item expanded "><a href="chapter_6_3.html"><strong aria-hidden="true">6.3.</strong> Rendering CHR Rom Tiles</a></li><li class="chapter-item expanded "><a href="chapter_6_4.html"><strong aria-hidden="true">6.4.</strong> Rendering Static Screen</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> Emulating Joypads</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> PPU Scrolling</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> Emulating APU</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="afterwords.html">Afterword</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing NES Emulator in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="text-align:center"><img src="./images/intro.png" width="50%"/></div>
<h1><a class="header" href="#why-nes" id="why-nes">Why NES?</a></h1>
<p>NES was one of the most popular gaming platforms through the 80ies and the 90ies. The platform and the emergent ecosystem was and still is a huge cultural phenomenon. The device itself had relatively simple hardware  (judging from the modern days), and it's incredible how much was made out of it. </p>
<p>This series is about creating an emulator capable of running and playing first-gen NES games, like </p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Pac-Man">PacMan</a></li>
<li><a href="https://en.wikipedia.org/wiki/Donkey_Kong">Donkey Kong</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ice_Climber">Ice Climber</a></li>
<li><a href="https://en.wikipedia.org/wiki/Super_Mario_Bros">Super Mario Bros</a></li>
<li>etc</li>
</ul>
<p>We would go with incremental updates, with potentially enjoyable milestones, gradually building a fully capable platform. One of the problems in writing an emulator is that you can't get any feedback until the end. Until the whole thing is done, and that's no fun. I've tried to break the entire exercise into small pieces with visible and playable goals. After all, it's all about having a good time. </p>
<h1><a class="header" href="#why-rust" id="why-rust">Why Rust?</a></h1>
<p>Rust is a modern language with modern expressing capabilities and impressive performance characteristics. </p>
<blockquote>
<p>For an overview of the language I recommend watching <a href="https://www.youtube.com/watch?v=DnT-LUQgc7s">&quot;Consider Rust&quot;</a> presentation by Jon Gjengse</p>
</blockquote>
<p>The language allows us to go as low-level as needed in terms of hardware and memory management, which looks like a good fit for the problem of hardware simulation. For example, NES has a Central Processing Unit (CPU), and the majority of supported operations are dealing with unsigned 8bit arithmetic and bits manipulation. Rust provides excellent capabilities for working with signed and unsigned numbers of different sizes without any overhead. And Rust ecosystem offers a plethora of libraries that make working on bit-level data as convenient as it gets. </p>
<p>The goal is to play NES games on the hardware we have, meaning we have to simulate NES hardware. That alone implies that we are introducing significant performance overhead in comparison to running native applications. 
By choosing rust, we hope to get some additional performance budget for our needs. NES hardware specs are pretty modest in today's standards. For example, the NES CPU is about 3000 times slower than modern CPUs. Emulating that in any language should not be a problem. Some folks were able to get playable performance on an emulator written in python. But it is still nice to have extra power for free. </p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<p>I expect the reader to have a basic knowledge of Rust language, understanding primary language constructs, and platform capabilities. I'll introduce some features as we go, but others have to be learned elsewhere.</p>
<p>It's also assumed that the reader has a basic understanding of bit arithmetic, boolean logic, and how binary and hexadecimal numbering systems work. Again NES is a relatively simple platform, and the NES CPU instructions set is small and straightforward, but some basic understanding of computer systems is required. </p>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ol>
<li><a href="http://wiki.nesdev.com/w/index.php/Nesdev_Wiki">Nesdev Wiki</a> - nothing would be possible without it. The one-stop-shop.</li>
<li><a href="http://nesdev.com/NESDoc.pdf">Nintendo Entertainment System Documentation</a> - a short tutorial that covers pretty much everything about NES</li>
<li><a href="https://nerdy-nights.nes.science/">Nintendo Age Nerdy Nights</a> - a series to help people write games for the NES</li>
<li><a href="https://www.goodreads.com/book/show/23461364-i-am-error">I.Am.Error</a> - a book full of histories of the Nintendo Entertainment System platform</li>
<li><a href="https://www.goodreads.com/book/show/910789.The_Elements_of_Computing_Systems">The Elements of Computing Systems</a> - everything you need to know about computer systems, how to build Tetris starting from logical gates. </li>
</ol>
<hr />
<p>Created by <a href="http://twitter.com/bugzmanov">@bugzmanov</a>, 2020</p>
<h1><a class="header" href="#understanding-the-nes-platform" id="understanding-the-nes-platform">Understanding the NES Platform</a></h1>
<h2><a class="header" href="#achitecture" id="achitecture">Achitecture</a></h2>
<p>The simplified architecture of hardware-software interaction looks like this:</p>
<div style="text-align:center"><img src="./images/ch2/image_1_computer_arch.png" width="30%"/></div>
<p>From top to bottom: </p>
<ul>
<li>Applications are running business logic and interact with hardware through an Operating System. </li>
<li>An Operating System is communicating with hardware using machine language. </li>
<li>On a hardware level, each device can be seen as an array of memory elements or processing units (or both). From this perspective, NES joypad is nothing more than an array of eight 1-bit items, each representing a pressed/released state of a button</li>
<li>Layers below ALU and Memory elements are less of an interest to us. On a hardware level, it all comes down to logic gates and their arrangements. </li>
</ul>
<blockquote>
<p>If you want to get intimate knowledge of how computers are composed, starting from basic principles of boolean logic, I highly recommend the book:<br/> <a href="https://www.goodreads.com/book/show/910789.The_Elements_of_Computing_Systems">&quot;The Elements of Computing Systems. Building a Modern Computer from First Principles&quot;</a> by Noam Nisan, Shimon Schocken.</p>
</blockquote>
<p>Luckily for us, NES doesn't have an Operating System. That means that the Application layer (Gamezzz) communicates with hardware directly, still using machine language.</p>
<p>The symplified version of this layered architecture looks like this:</p>
<div style="text-align:center"><img src="./images/ch2/image_2_nes_emul_arch.png" width="30%"/></div>
<p>As you can see, the machine language is the interface between our emulator and  NES games.</p>
<p>In the coming emulator, we would need to implement NES Computer Architecture, Arithmetic Logic Unit, and Memory. By using high-level language, we don't need to worry about simulating boolean arithmetic and sequential logic. We would rely on existing Rust features and language constructs.</p>
<h2><a class="header" href="#nes-platform-main-components" id="nes-platform-main-components">NES Platform Main Components</a></h2>
<div style="text-align:center"><img src="./images/ch2/image_3_nes_components.png" width="50%"/></div>
<p>The significantly simplified schema of main NES hardware components: </p>
<ul>
<li>
<p>Central Processing Unit (<strong>CPU</strong>) is a modified version of <a href="https://en.wikipedia.org/wiki/MOS_Technology_6502">6502 chip</a> - 2A03. As with any CPU, the goal of this module is to execute the main program instructions. </p>
</li>
<li>
<p>Picture Processing Unit (<strong>PPU</strong>) - was based on chip 2C02 made by the same company that made CPU - Ricoh. This module's primary goal is to draw the current state of a game on a TV Screen. </p>
</li>
<li>
<p>Both CPU and PPU have access to their 2 KiB (2048 bytes) banks of Random Access Memory (<strong>RAM</strong>)</p>
</li>
<li>
<p>Audio Processing Unit (<strong>APU</strong>) - the module is a part of 2A03 chip and is responsible for generating specific five-channel based sounds, that made NES chiptunes so recognizable.</p>
</li>
<li>
<p>Cartridges - were an essential part of the platform, mainly because the console didn't have an operating system. Each cartridge carried at least two large ROM chips - Character ROM (CHR ROM) and Program ROM (PRG ROM). The former stored video graphics data of a game, the latter stored CPU instructions - code of a game. 
(in reality, when a cartridge is inserted into the slot CHR Rom is connected directly to PPU, while PRG Rom is connected directly to CPU)
The later version of cartridges carried additional hardware (ROM and RAM) accessible through so-called mappers. That explains why later games had provided significantly better gameplay and visuals despite running on the same console hardware. </p>
</li>
</ul>
<div style="text-align:center"><img src="./images/ch2/image_4_cartridge.png" width="50%"/></div>
<ul>
<li>Gamepads - have a distinct goal to read inputs from a gamer and make it available for game logic. As we will learn later, the fact that the gamepad for the 8-bit platform has only eight buttons is not a coincidence. </li>
</ul>
<p>What's interesting is that CPU, PPU, and APU are independent of each other. This fact makes NES a distributed system in which separate components have to coordinate to generate one seamless gaming experience.</p>
<p>We can use the schema of the main NES components as an implementation plan for our emulator. </p>
<div style="text-align:center"><img src="./images/ch2/image_6_impl_plan.png" width="80%"/></div>
<p>We have to build a simulation of all of these modules. The goal is to have something playable as soon as possible. Using iterative approach, we would incrementally add features to achieve the goal. </p>
<p>I'm roughly estimating the effort required for each component in percentages. PPU is the hardest one, and the BUS is the easiest.</p>
<p>Writing a perfect emulator is a never-ending quest. But this quest has a start. And we will start by emulating the CPU.</p>
<div style="text-align:center"><img src="./images/ch2/image_5_motherboard.png" width="80%"/></div>
<h1><a class="header" href="#emulating-cpu" id="emulating-cpu">Emulating CPU</a></h1>
<p>The goal of this chapter is to have our first NES game up and running. 
We are going to play the Snake game. The source code with comments can be found <a href="https://gist.github.com/wkjagt/9043907">this gist</a>.</p>
<div style="text-align:center"><img src="./images/ch3/snk_logo.png" width="40%"/></div>
 <div style="text-align:center"><img src="./images/ch3/snk_game.gif" width="40%"/></div>
<p>CPU is the heart of any computer system. It's the CPUs job to run program instructions and orchestrate all available hardware modules to provide the full experience. Despite PPU and APU running their independent circuits, they still have to march under CPUs beat and execute commands issued by the CPU. </p>
<p>Before jumping into implementation, we need to briefly discuss which resources are available to the CPU to do its work.</p>
<p>The only two resources the CPU has access to are the Memory Map and Cpu Registers. </p>
<p>From a programming standpoint, memory map is just a continuous array of 1-byte cells. NES Cpu uses 16bit for memory addressing, which means that it can address 65536 different memory cells. </p>
<p>As we've seen before, the NES platform had only 2 KiB of RAM connected to the CPU. </p>
<div style="text-align:center"><img src="./images/ch3/cpu_registers_memory.png" width="80%"/></div>
<p>That RAM is accessible via <strong>[0x0000 … 0x2000]</strong> address space. </p>
<p>Access to <strong>[0x2000 … 0x4020]</strong> is redirected to other available NES hardware modules: PPU, APU, GamePads, etc. (more on this later)</p>
<p>Access to <strong>[0x4020 .. 0x6000]</strong> is a special space that different generations of cartridges used differently. It might be mapped to nothing at all, RAM, ROM, etc. The space is controlled by so-called mappers - special circuitry on a cartridge. We would ignore this space.</p>
<p>Access to <strong>[0x6000 .. 0x8000]</strong> is reserved to a RAM space on a cartridge if a cartridge has one. It was used in games like Zelda for storing and retrieving the game state. We would ignore this space.</p>
<p>Access to <strong>[0x8000 … 0x10000]</strong> is mapped to Program ROM (PRG ROM) space on a cartridge. </p>
<p>Memory access is relatively slow, NES CPU has a few internal memory slots called registers with significantly lower access delay.</p>
<blockquote>
<table><thead><tr><th>CPU Operation type</th><th>Execution time (in CPU Cycles)</th></tr></thead><tbody>
<tr><td>Accesing only registers</td><td>2</td></tr>
<tr><td>Accessing the first 255 bytes of RAM</td><td>3</td></tr>
<tr><td>Accessing memory space after the first 255</td><td>4-7</td></tr>
</tbody></table>
</blockquote>
<p>NES CPU has 7 Registers:</p>
<ul>
<li>
<p>Program Counter (<em>PC</em>) - holds the address for the next machine language instruction to be executed</p>
</li>
<li>
<p>Stack Pointer - Memory space [0x0100 .. 0x1FF] is used for stack. The stack pointer holds the address of the top of that space. NES Stack (as all stacks) grows from top to bottom: when a byte got pushed to the stack - SP register decrements  and when a byte is retrieved from the stack - SP register increments</p>
</li>
<li>
<p>Accumulator (<em>A</em>) - stores results of arithmetic, logic, and memory access operations. Being used as an input parameter for some of the operations.</p>
</li>
<li>
<p>Index Register X (<em>X</em>) - used as an offset in specific memory addressing modes (more on this later). Can be used for auxiliary needs (holding temp values, being used as a counter, etc.)</p>
</li>
<li>
<p>Index Register Y (<em>Y</em> -  similar use cases as with register X.</p>
</li>
<li>
<p>Processor status (<em>P</em>) - 8bit register represents 7 status flags that can be set or erased depending on the result of the last executed instruction ( for example Z flag is set (1) if the result of an operation is 0, and is erased (0) otherwise)</p>
</li>
</ul>
<p>Each CPU comes with a predefined hard-wired instruction set that defines everything a CPU can do.</p>
<p>CPU receives instructions from the application layer in the form of machine codes. And you can think of machine language as a thin layer connecting software and hardware. </p>
<p>A full list of the official 6502 instructions can be found:</p>
<ul>
<li><a href="http://www.obelisk.me.uk/6502/reference.html">http://www.obelisk.me.uk/6502/reference.html</a></li>
<li>or <a href="http://www.6502.org/tutorials/6502opcodes.html">http://www.6502.org/tutorials/6502opcodes.html</a></li>
</ul>
<p>I tend to use both of the links. The pages provide full specs of available CPU features and their machine codes. </p>
<p>I highly recommend reading this <a href="https://skilldrick.github.io/easy6502/">interactive tutorial on the 6502 instructions</a> before moving on </p>
<div style="text-align:center"><img src="./images/ch3/image_4_opcodes.png" width="80%" /></div>
<p>6502 chip is a relatively simple CPU; it supports only six types of commands and about 64 unique commands. Because some of the instructions have multiple versions (for different memory addressing modes), it results in about 150 machine code operations that we are to implement. </p>
<blockquote>
<p><strong>NOTE:</strong> NES console had a custom chip 2A03 that is based on 6502, but has noticeable differences:</p>
<ul>
<li>in addition to official machine operations, it had about 110 unofficial additional opcodes (luckily, about a third of them are No-OPs)</li>
<li>it had Audio Processing Unit on-board</li>
<li>it didn't support decimal mode for arithmetic</li>
</ul>
<p>To keep things simple, we would need to implement support for 256 different machine instructions. </p>
<p>The good news is that there are a lot of similarities between instructions. Once we have the foundation in place, we would constantly be re-using it to implement the whole set.</p>
</blockquote>
<h1><a class="header" href="#lets-get-started" id="lets-get-started">Let's get started.</a></h1>
<div style="text-align:center"><img src="./images/ch3/chapter_logo.png" width="20%"/></div>
<p>Let's try to interpret our first program. The program looks like this:</p>
<pre><code>a9 c0 aa e8 00
</code></pre>
<p>This is somewhat cryptic and isn't designed to be read by humans. But we can more easily decipher what's going on if we represent the program in <a href="https://en.wikipedia.org/wiki/Assembly_language">assembly code</a></p>
<div style="text-align:center"><img src="./images/ch3.1/image_1_assembler.png" width="40%"/></div>
<p>Now it's more readable: it consists of 4 instructions, and the first instruction has a parameter.</p>
<p>Let's interpret what's going on using the opcode specification from <a href="http://www.obelisk.me.uk/6502/reference.html">6502 Instruction Reference</a></p>
<div style="text-align:center"><img src="./images/ch3.1/image_2_lda_spec.png" width="50%"/></div>
<p>It looks like that the command loads a hexadecimal value 0xC0 into the accumulator CPU register. And it also has to update some bits in Processor Status register P (namely, bit 1 - Zero Flag and bit 7 - Negative Flag). </p>
<blockquote>
<p><strong>LDA</strong> spec shows that the opcode <strong>0xA9</strong> has one parameter - the instruction size is 2 bytes: one byte is for operation code itself (standard for all NES CPU opcodes), and the other is for a parameter. </p>
<p>NES Opscodes can have no explicit parameters or one explicit parameter. For some operations, the explicit parameter can take 2 bytes. And in that case, the machine instruction would occupy 3 bytes.</p>
<p>Worth mentioning, that some operations use CPU registers as implicit parameters.</p>
</blockquote>
<p>Let's sketch out how our CPU might look like from a high-level perspective:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct CPU {
   pub register_a: u8,
   pub status: u8,
   pub program_counter: u16,
}
 
impl CPU {
   pub fn new() -&gt; Self {
       CPU {
           register_a: 0,
           status: 0,
           program_counter: 0,
       }
   }
 
   pub fn interpret(&amp;mut self, program: Vec&lt;u8&gt;) {
       todo!(&quot;&quot;)
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that we introduced a program counter register that would help us track our current position in the program. Also, note that the interpret method takes a mutable reference to self as we know that we would need to modify <strong>register_a</strong> during the execution.</p>
<p>The CPU works in a constant cycle:</p>
<ul>
<li>Fetch next execution instruction from the instruction memory</li>
<li>Decode the instruction</li>
<li>Execute the Instruction</li>
<li>Repeat the cycle</li>
</ul>
<p>Lets try to codify exactly that:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn interpret(&amp;mut self, program: Vec&lt;u8&gt;) {
    self.program_counter = 0;

    loop {
        let opscode = program[self.program_counter as usize];
        self.program_counter += 1;

        match opscode {
            _ =&gt; todo!()
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So far so good. Endless loop? Nah, it's gonna be alright. Now let's implement the <strong>LDA (0xA9)</strong> opcode:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>        match opscode {
            0xA9 =&gt; {
                let param = program[self.program_counter as usize];
                self.program_counter +=1;
                self.register_a = param;

                if result == 0 {
                    self.status = self.status | 0b0000_0001;
                } else {
                    self.status = self.status &amp; 0b1111_1110;
                }

                if result &amp; 0b1000_0000 != 0 {
                    self.status = self.status | 0b1000_0000;
                } else {
                    self.status = self.status &amp; 0b0111_1111;
                }

            }
            _ =&gt; todo!()
        }
<span class="boring">}
</span></code></pre></pre>
<p>We are not doing anything crazy here, just following the spec. And using rust constructs to do binary arithmetic.</p>
<blockquote>
<p>It's essential to set or erase CPU flag status depending on the results.</p>
</blockquote>
<p>Because of the endless loop, we won't be able to test this functionality yet. Before moving on, let's quickly implement <strong>BRK (0x00)</strong> opcode:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>        match opcode {
        // ...
            0x00 =&gt; {
                return;
            }
            _ =&gt; todo!()
        }
<span class="boring">}
</span></code></pre></pre>
<p>Now we can write some tests:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
   use super::*;
 
   #[test]
   fn test_0xa9_lda_immidiate_load_data() {
       let mut cpu = CPU::new();
       cpu.interpret(vec![0xa9, 0x05, 0x00]);
       assert_eq!(cpu.register_a, 0x05);
       assert!(cpu.status &amp; 0b0000_0001 == 0);
       assert!(cpu.status &amp; 0b1000_0000 == 0);
   }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Do you think that's enough? What else should we check? </p>
</blockquote>
<p>Alright. Let's try to implement another opcode, shall we? </p>
<div style="text-align:center"><img src="./images/ch3.1/image_3_tax_spec.png" width="50%"/></div>
<p>This one is also straightforward: copy a value from A to X, and update status register.</p>
<p>We need to introduce <strong>register_x</strong> in our CPU struct, and then we can implement the <strong>TAX (0xAA)</strong> opcode:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct CPU {
//...
   pub register_x: u8,
}
 
impl CPU {
// ...    
    pub fn interpret(&amp;mut self, program: Vec&lt;u8&gt;) {
// ...
        match opscode {
            //...  
            0xAA =&gt;  {
                self.register_x = self.register_a;
            
                if result == 0 {
                    self.status = self.status | 0b0000_0001;
                } else {
                    self.status = self.status &amp; 0b1111_1110;
                }

                if result &amp; 0b1000_0000 != 0 {
                    self.status = self.status | 0b1000_0000;
                } else {
                    self.status = self.status &amp; 0b0111_1111;
                }

            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Don't forget to write tests:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   #[test]
   fn test_0xaa_tax_move_a_to_x() {
       let mut cpu = CPU::new();
       cpu.register_a = 10;
       cpu.interpret(vec![0xaa, 0x00]);
 
       assert_eq!(cpu.register_x, 10)
   }
<span class="boring">}
</span></code></pre></pre>
<p>Before moving to the next opcode, we have to admit that our code becomes quite convoluted:</p>
<ul>
<li>interpret method is already complicated and does multiple things</li>
<li>there is a noticeable duplication between the way <strong>TAX</strong> and <strong>LDA</strong> are implemented.</li>
</ul>
<p>Let's fix that: </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// ... 
  fn lda(&amp;mut self, value: u8) {
       self.register_a = value;
       self.update_zero_and_negative_flags(self.register_a);
   }
 
   fn tax(&amp;mut self) {
       self.register_x = self.register_a;
       self.update_zero_and_negative_flags(self.register_x);
   }
  
    fn update_zero_and_negative_flags(&amp;mut self, result: u8) {
        if result == 0 {
            self.status = self.status | 0b0000_0001;
        } else {
            self.status = self.status &amp; 0b1111_1110;
        }

        if result &amp; 0b1000_0000 != 0 {
            self.status = self.status | 0b1000_0000;
        } else {
            self.status = self.status &amp; 0b0111_1111;
        }
    }
// ...    
    pub fn interpret(&amp;mut self, program: Vec&lt;u8&gt;) {
// ...
        match opscode {
            0xA9 =&gt; {
                let param = program[self.program_counter as usize];
                self.program_counter += 1;
                
                self.lda(param);
            }

            0xAA =&gt; self.tax(),

            0x00 =&gt; return,
            
            _ =&gt; todo!(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok. Looks more manageable now. And hopefully, all tests are still passing. </p>
<p>I cannot emphasize enough the importance of writing tests for all opcodes we are implementing. The operations themselves are almost trivial, but tiny accidental mistakes can unpredictably ripple a game logic.</p>
<div style="text-align:center"><img src="./images/ch3.1/image_4_pacman_bug.gif" width="30%"/></div>
<p>Implementing that last opcode from the program should not be a problem, and I'll leave this exercise to you. </p>
<p>At the end, these tests should be passing: </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   #[test]
   fn test_5_ops_working_together() {
       let mut cpu = CPU::new();
       cpu.interpret(vec![0xa9, 0xc0, 0xaa, 0xe8, 0x00]);
 
       assert_eq!(cpu.register_x, 0xc1)
   }

    #[test]
    fn test_inx_overflow() {
        let mut cpu = CPU::new();
        cpu.register_x = 0xff;
        cpu.interpret(vec![0xe8, 0xe8, 0x00]);

        assert_eq!(cpu.register_x, 1)
    }
<span class="boring">}
</span></code></pre></pre>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch3.1" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#memory-addressing-modes" id="memory-addressing-modes">Memory addressing modes</a></h1>
<p>In our initial implementation, the CPU receives instructions as a separate input stream, this is not how the things actually work.</p>
<p>NES implements typical von Neumann architecture: both data and the instructions are stored in memory. The execution code is data from the CPU perspective, and any data can potentially be interpreted as an execution code. There is no way CPU can tell the difference. The only mechanism the CPU has is a <strong>program_counter</strong> register that keeps track of a position in the instructions stream.</p>
<div style="text-align:center"><img src="./images/ch3.2/image_1_von_neuman.png" width="60%"/></div>
<p>Let's sketch this out in our CPU code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>pub struct CPU {
   pub register_a: u8,
   pub register_x: u8,
   pub status: u8,
   pub program_counter: u16,
   memory: [u8; 0xFFFF]
}
 
impl CPU {
 
    fn mem_read(&amp;self, addr: u16) -&gt; u8 {
        self.memory[addr as usize]
    }

    fn mem_write(&amp;mut self, addr: u16, data: u8) {
        self.memory[addr as usize] = data;
    }

    pub fn load_and_run(&amp;mut self, program: Vec&lt;u8&gt;) {
        self.load(program);
        self.run()
    }

    pub fn load(&amp;mut self, program: Vec&lt;u8&gt;) {
        self.memory[0x8000 .. (0x8000 + program.len())].copy_from_slice(&amp;program[..]);
        self.program_counter = 0x8000;
    }
 
    pub fn run(&amp;mut self) {
    // note: we move  intialization of program_counter from here to load function
        loop {
            let opscode = self.mem_read(self.program_counter);
            self.program_counter += 1;

            match opscode {
                //..
            }
        }
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>For now, we just created an array for the whole 64 KiB of address space. As discussed in <LINK TO A CHAPTER>, CPU has only 2 KiB of RAM, and everything else is reserved for memory mapping. </p>
<p>We also load program code into memory, starting at 0x8000 address. We've discusses that [0x8000 .. 0xFFFF] is reserved for Program ROM. And we can assume that the instructions stream would start somewhere in this space, just not necessarily exactly at 0x8000.</p>
<p>NES platform has a special mechanism to notify where should CPU start the execution - upon inserting a new cartridge the CPU received special signal called &quot;Reset interrupt&quot; that instructs CPU to:</p>
<ul>
<li>reset the state (registers and flags)</li>
<li>set <strong>program_counter</strong> to the 16bit address that is stored at 0xFFFC</li>
</ul>
<p>Before implementing that, I should briefly mention that NES CPU can address 65536 memory cells. It takes 2 bytes to store an address. NES CPU uses Little-Endian addressing rather than Big-Endian.
That means that 8 liest significant bits of an address will be stored before 8 most significant bits. </p>
<p>To illustrate the difference:</p>
<table><thead><tr><th></th><th align="right"></th></tr></thead><tbody>
<tr><td>Real Address</td><td align="right"><strong>0x8000</strong></td></tr>
<tr><td>Address packed in big-endian</td><td align="right"><strong>80 00</strong></td></tr>
<tr><td>Address packed in little-endian</td><td align="right"><strong>00 80</strong></td></tr>
</tbody></table>
<p>For example, the instruction to read data from memory cell 0x8000 into A register would look like:</p>
<pre><code>LDA $8000      &lt;=&gt;    ad 00 80
</code></pre>
<p>We can implement this behaviour using rust bit arithetic:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   fn mem_read_u16(&amp;mut self, pos: u16) -&gt; u16 {
       let lo = self.mem_read(pos) as u16;
       let hi = self.mem_read(pos + 1) as u16;
       (hi &lt;&lt; 8) | (lo as u16)
   }
 
   fn mem_write_u16(&amp;mut self, pos: u16, data: u16) {
       let hi = (data &gt;&gt; 8) as u8;
       let lo = (data &amp; 0xff) as u8;
       self.mem_write(pos, lo);
       self.mem_write(pos + 1, hi);
   }

<span class="boring">}
</span></code></pre></pre>
<p>Or by using rust lang <a href="https://doc.rust-lang.org/std/primitive.u16.html#method.from_le_bytes">endian support for primitive types</a></p>
<p>Now we can implement <strong>reset</strong> functionality properly. We will have to adjust <code>load</code> and <code>load_and_run</code> functions:</p>
<ul>
<li><strong>load</strong> method should load a program into PRG ROM space and save the reference to the code into 0xFFFC memory cell</li>
<li><strong>reset</strong> method should restore the state of all registers, and initialize program_counter by the 2-byte value stored at 0xFFFC</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   pub fn reset(&amp;mut self) {
       self.register_a = 0;
       self.register_x = 0;
       self.status = 0;
 
       self.program_counter = self.mem_read_u16(0xFFFC);
   }
 
   pub fn load(&amp;mut self, program: Vec&lt;u8&gt;) {
       self.memory[0x8000 .. (0x8000 + program.len())].copy_from_slice(&amp;program[..]);
       self.mem_write_u16(0xFFFC, 0x8000);
   }
 
   pub fn load_and_run(&amp;mut self, program: Vec&lt;u8&gt;) {
       self.load(program);
       self.reset();
       self.run()
   }

<span class="boring">}
</span></code></pre></pre>
<p>Don't forget to fix failing tests now <strong>:trollface:</strong></p>
<p>Alright, that was the easy part. </p>
<p>Remember LDA  opscode we've implemented last chapter? That single mnemonic (LDA) actually can be traslated into 8 different machine instructions depending on a type of the parameter:</p>
<div style="text-align:center"><img src="./images/ch3.2/image_2_opcodes.png" width="80%"/></div>
<p>You can read about addressing modes: </p>
<ul>
<li><a href="https://skilldrick.github.io/easy6502/#addressing">here</a></li>
<li>and <a href="www.obelisk.me.uk/6502/addressing.html">here</a></li>
</ul>
<p>In short, the addressing mode is a property of an instruction that defines how CPU would interpret the next 1 or 2 bytes in the instruction stream. </p>
<p>Different addressing modes have different instruction sizes. 
For example, </p>
<ul>
<li><strong>Zero Page version</strong> ($A5) has a size of 2 bytes - one for opcode itself, and one for a parameter. That's why zero page addressing can't reference memory above the first 255 bytes.</li>
<li><strong>Absolute version</strong> ($AD) has 3 bytes - that means that the Address occupies 2 bytes, making it possible to reference all of 65536 memory cells, as we've discussed.
(<em>NOTE: 2 byte the parameter will be packed according to little-endian rules</em>)</li>
</ul>
<p>There are no opcodes that occupy more than 3 bytes. CPU instruction size can be either 1 or 2 or 3 bytes. </p>
<p>The majority of CPU instructions provide more than one addressing alternative. Ideally, we don't want to re-implement the same addressing mode logic for every CPU instruction.</p>
<p>Let's try to codify how CPU should interpret different addressing modes:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>#[derive(Debug)]
#[allow(non_camel_case_types)]
pub enum AddressingMode {
   Immediate,
   ZeroPage,
   ZeroPage_X,
   ZeroPage_Y,
   Absolute,
   Absolute_X,
   Absolute_Y,
   Indirect_X,
   Indirect_Y,
   NoneAddressing,
}
 
impl CPU {
   // ...
   fn get_operand_address(&amp;self, mode: &amp;AddressingMode) -&gt; u16 {
 
       match mode {
           AddressingMode::Immediate =&gt; self.program_counter,
 
           AddressingMode::ZeroPage  =&gt; self.mem_read(self.program_counter) as u16,
          
           AddressingMode::Absolute =&gt; self.mem_read_u16(self.program_counter),
        
           AddressingMode::ZeroPage_X =&gt; {
               let pos = self.mem_read(self.program_counter);
               let addr = pos.wrapping_add(self.register_x) as u16;
               addr
           }
           AddressingMode::ZeroPage_Y =&gt; {
               let pos = self.mem_read(self.program_counter);
               let addr = pos.wrapping_add(self.register_y) as u16;
               addr
           }
 
           AddressingMode::Absolute_X =&gt; {
               let base = self.mem_read_u16(self.program_counter);
               let addr = base.wrapping_add(self.register_x as u16);
               addr
           }
           AddressingMode::Absolute_Y =&gt; {
               let base = self.mem_read_u16(self.program_counter);
               let addr = base.wrapping_add(self.register_y as u16);
               addr
           }
 
           AddressingMode::Indirect_X =&gt; {
               let base = self.mem_read(self.program_counter);
 
               let ptr: u8 = (base as u8).wrapping_add(self.register_x);
               let lo = self.mem_read(ptr as u16);
               let hi = self.mem_read(ptr.wrapping_add(1) as u16);
               (hi as u16) &lt;&lt; 8 | (lo as u16)
           }
           AddressingMode::Indirect_Y =&gt; {
               let base = self.mem_read(self.program_counter);
 
               let lo = self.mem_read(base as u16);
               let hi = self.mem_read((base as u8).wrapping_add(1) as u16);
               let deref_base = (hi as u16) &lt;&lt; 8 | (lo as u16);
               let deref = deref_base.wrapping_add(self.register_y as u16);
               deref
           }
         
           AddressingMode::NoneAddressing =&gt; {
               panic!(&quot;mode {:?} is not supported&quot;, mode);
           }
       }
 
   }

<span class="boring">}
</span></code></pre></pre>
<p>That way, we can change our initial <strong>LDA</strong> implementation. </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span> fn lda(&amp;mut self, mode: &amp;AddressingMode) {
       let addr = self.get_operand_address(mode);
       let value = self.mem_read(addr);
      
       self.register_a = value;
       self.update_zero_and_negative_flags(self.register_a);
   }
 
 
   pub fn run(&amp;mut self) {
       loop {
           let code = self.mem_read(self.program_counter);
           self.program_counter += 1;
 
           match code {
               0xA9 =&gt; {
                   self.lda(&amp;AddressingMode::Immediate);
                   self.program_counter += 1;
               }
               0xA5 =&gt; {
                   self.lda(&amp;AddressingMode::ZeroPage);
                   self.program_counter += 1;
               }
               0xAD =&gt; {
                   self.lda(&amp;AddressingMode::Absolute);
                   self.program_counter += 2; 
               }
               //....
           }
       }
   }

<span class="boring">}
</span></code></pre></pre>
<p>NOTE: It's absolutely necessary to increment <strong>program_counter</strong> after each byte being read from the instructions stream. </p>
<p>Don't forget the tests.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   #[test]
   fn test_lda_from_memory() {
       let mut cpu = CPU::new();
       cpu.mem_write(0x10, 0x55);
 
       cpu.load_and_run(vec![0xa5, 0x10, 0x00]);
 
       assert_eq!(cpu.register_a, 0x55);
   }
<span class="boring">}
</span></code></pre></pre>
<p>Using the same foundation, we can quickly implement <strong>STA</strong> instruction, which copies the value from register A to memory.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    fn sta(&amp;mut self, mode: &amp;AddressingMode) {
        let addr = self.get_operand_address(mode);
        self.mem_write(addr, self.register_a);
    }


    pub fn run(&amp;mut self) {
//... 
        match code {
            //.. 
            /* STA */
            0x85 =&gt; {
                self.sta(AddressingMode::ZeroPage);
                self.program_counter += 1;
            }

            0x95 =&gt; {
                self.sta(AddressingMode::ZeroPage_X);
                self.program_counter += 1;
            } 
            //..
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Before we wrap up, I'd like to mention that the current <strong>run</strong> method is somewhat iffy.
First, the requirement to increment program_counter by 1 (or 2) after some of the operations is error-prone. And if we introduce an error, it would be tough to spot it. </p>
<p>Second, wouldn't it be more readable and convenient if we could group all &quot;LDA&quot; operations under a single <code>match</code> cause? </p>
<p>Lastly, all we do is hardcoding Instructions spec into Rust code. And the translation is a bit hard to compare. Keeping the code in some table form looks like a more manageable approach. </p>
<div style="text-align:center"><img src="./images/ch3.2/image_3_ideal_state.png" width="80%"/></div>
<p>I leave it to you to figure out how to get to this point.</p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch3.2" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#implementing-the-rest-of-cpu-instructions" id="implementing-the-rest-of-cpu-instructions">Implementing the rest of CPU instructions</a></h1>
<div style="text-align:center"><img src="./images/ch3.3/image_1_how_to_draw_owl.png" width="60%"/></div>
<p>Implementing the rest of the 6502 CPU instructions should be relatively straightforward. I wouldn't go into detail with every one of them. </p>
<p>Just some remarks:</p>
<ul>
<li><strong>ADC</strong> is perhaps the most complicated instruction from a logic flow perspective. Note that the spec contains details regarding decimal mode, that can be entirely skipped because Ricoh modification of the chip didn't support decimal mode.</li>
</ul>
<blockquote>
<p>This article goes into a detailed overview of how binary arithmetic is implemented in 6502: <a href="http://www.righto.com/2012/12/the-6502-overflow-flag-explained.html">The 6502 overflow flag explained mathematically </a></p>
<p>For the curious and brave souls: <a href="http://www.righto.com/2013/01/a-small-part-of-6502-chip-explained.html">The 6502 CPU's overflow flag explained at the silicon level </a></p>
</blockquote>
<ul>
<li>
<p>After ADC is implemented, implementing <strong>SBC</strong> becomes trivial as
<code>A - B = A + (-B)</code>. 
And <code>-B = !B + 1</code> </p>
</li>
<li>
<p><strong>PHP</strong>, <strong>PLP</strong> and <strong>RTI</strong> have to deal with <a href="http://wiki.nesdev.com/w/index.php/Status_flags#The_B_flag">2 bit B-flag</a>. Except for interrupts execution, those are the only commands that directly influence (or being directly influenced by) 5th Bit of <strong>Status register P</strong></p>
</li>
<li>
<p>Majority of branching and jumping operations can be implemented by merely modifying <strong>program_counter</strong> register. However, be careful not to increment the register within the same instruction interpret cycle. </p>
</li>
</ul>
<p>If you get stuck, you can always look up the implementation of 6502 instruction set here: <link to code></p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch3.3" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#running-our-first-game" id="running-our-first-game">Running our first game</a></h1>
<div style="text-align:center"><img src="./images/ch3.4/image_1_progress.png" width="100%"/></div>
<p>Great, you've made it this far. What we are going to do next is a bit of a detour. 
The snake game was introduced in this article: <a href="https://skilldrick.github.io/easy6502/#snake">Easy 6502</a>. In fact, it is not a truly NES game. It is built on top of 6502 instructions but uses quate different memory mappings.</p>
<p>However, it's a fun way to validate that our CPU is truly functional, and it's fun to play the first game. </p>
<p>The majority of logic we are to implement now would be reused some way or another when we will be implementing rendering in PPU. So nothing is a wasted effort. </p>
<p>The machine code of the game:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>let game_code = vec![
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
    0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
    0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
    0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
    0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
    0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
    0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
    0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
    0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
    0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
    0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
    0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
    0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
    0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
    0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
    0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
    0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
    0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
    0xea, 0xca, 0xd0, 0xfb, 0x60
];

<span class="boring">}
</span></code></pre></pre>
<p>You can find assembly code with comments <a href="https://gist.github.com/wkjagt/9043907">here</a></p>
<p>The memory mapping that the game uses:</p>
<table><thead><tr><th>Address space</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>0xFE</strong></td><td>Input</td><td>Random Number Generator</td></tr>
<tr><td><strong>0xFF</strong></td><td>Input</td><td>A code of the last pressed Button</td></tr>
<tr><td><strong>[0x0200..0x0600]</strong></td><td>Output</td><td>Screen.<br/>Each cell represents the color of a pixel in a 32x32 matrix.<br/><br/> The matrix starts from top left corner, i.e.<br/><br/> <strong>0x0200</strong> - the color of (0,0) pixel <br/> <strong>0x0201</strong> - (1,0) <br/> <strong>0x0220</strong> - (0,1) <br/><br/> <div style="text-align:left"><img src="./images/ch3.4/image_2_screen_matrix.png" width="50%"/></div></td></tr>
</tbody></table>
<p>The game executes standard game loop:</p>
<ul>
<li>read inputs from a user</li>
<li>compute game state</li>
<li>render game state to a screen</li>
<li>repeat</li>
</ul>
<p>We need to intercept this cycle, to get user input into the input mapping space, and render the state of the screen. Let's modify our CPU run cycle:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl CPU {
 // ...   
    pub fn run(&amp;mut self) {
        self.run_with_callback(|_| {});
    }

    pub fn run_with_callback&lt;F&gt;(&amp;mut self, mut callback: F)
    where
        F: FnMut(&amp;mut CPU),
    {
        let ref opcodes: HashMap&lt;u8, &amp;'static opcodes::OpCode&gt; = *opcodes::OPCODES_MAP;

        loop {
            callback(self);
            //....
            match code {
                //...
            }
            // ..
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, the client code can provide a callback that will be executed before every opcode interpretation cycle.</p>
<p>The sketch of the main method:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let game_code = vec![
// ...
   ];
 
   //load the game
   let mut cpu = CPU::new();
   cpu.load(game_code);
   cpu.reset();
 
   // run the game cycle
   cpu.run_with_callback(move |cpu| {
       // TODO:
       // read user input and write it to mem[0xFF]
       // update mem[0xFE] with new Random Number
       // read mem mapped screen state
       // render screen state
   });
}
</code></pre></pre>
<p>For our input-output, we would be using a cross-platform library
that's popular in gamedev - <a href="https://www.libsdl.org/">Simple DirectMedia Layer library</a>.</p>
<p>Luckily, there is a convenient crate that provides binding to the lib: <a href="https://rust-sdl2.github.io/rust-sdl2/sdl2/">rust-sdl2</a></p>
<ol start="0">
<li>Let's add it to Cargo.toml:</li>
</ol>
<pre><code class="language-toml"># ...

[dependencies]
lazy_static = &quot;1.4.0&quot;
bitflags = &quot;1.2.1&quot;

sdl2 = &quot;0.34.0&quot;
rand = &quot;=0.7.3&quot;
</code></pre>
<ol>
<li>First, we need to initialize sdl:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">use sdl2::event::Event;
use sdl2::EventPump;
use sdl2::keyboard::Keycode;
use sdl2::pixels::Color;
use sdl2::pixels::PixelFormatEnum;
 
fn main() {
   // init sdl2
   let sdl_context = sdl2::init().unwrap();
   let video_subsystem = sdl_context.video().unwrap();
   let window = video_subsystem
       .window(&quot;Snake game&quot;, (32.0 * 10.0) as u32, (32.0 * 10.0) as u32)
       .position_centered()
       .build().unwrap();
 
   let mut canvas = window.into_canvas().present_vsync().build().unwrap();
   let mut event_pump = sdl_context.event_pump().unwrap();
   canvas.set_scale(10.0, 10.0).unwrap();
 
   //...
}
</code></pre></pre>
<p>Note: because our game screen is tiny (32x32 pixels), we set the scale factor to 10.</p>
<blockquote>
<p>Using <code>.unwrap()</code> is justifiable because it's the outer layer of our application. 
There are no other layers that potentially can handle Err values and do something about it.</p>
</blockquote>
<p>Next, we will create a texture that would be used for rendering:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//...
   let creator = canvas.texture_creator();
   let mut texture = creator
       .create_texture_target(PixelFormatEnum::RGB24, 32, 32).unwrap();
//...
<span class="boring">}
</span></code></pre></pre>
<p>We are instructing SDL that our texture would have size 32x32, and each pixel would be represented by 3 bytes (for <em>R</em>, <em>G</em> and <em>B</em> colors) - i.e., the texture should be represented by an array of 32<em>32</em>3 bytes.</p>
<ol start="2">
<li>Handling user input is straightforward:</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn handle_user_input(cpu: &amp;mut CPU, event_pump: &amp;mut EventPump) {
   for event in event_pump.poll_iter() {
       match event {
           Event::Quit { .. } | Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {
               std::process::exit(0)
           },
           Event::KeyDown { keycode: Some(Keycode::W), .. } =&gt; {
               cpu.mem_write(0xff, 0x77);
           },
           Event::KeyDown { keycode: Some(Keycode::S), .. } =&gt; {
               cpu.mem_write(0xff, 0x73);
           },
           Event::KeyDown { keycode: Some(Keycode::A), .. } =&gt; {
               cpu.mem_write(0xff, 0x61);
           },
           Event::KeyDown { keycode: Some(Keycode::D), .. } =&gt; {
               cpu.mem_write(0xff, 0x64);
           }
           _ =&gt; {/* do nothing */}
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>Rendering screen state is a bit trickier. 
Our program assumes 1 byte per pixel, while SDL expects 3 bytes. 
<br/>From the game point of view it doesn't matter much how we map colors, the only two color maps that are essential are: </li>
</ol>
<ul>
<li>0 - Black </li>
<li>1 - White</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn color(byte: u8) -&gt; Color {
   match byte {
       0 =&gt; sdl2::pixels::Color::BLACK,
       1 =&gt; sdl2::pixels::Color::WHITE,
       2 | 9 =&gt; sdl2::pixels::Color::GREY,
       3 | 10 =&gt; sdl2::pixels::Color::RED,
       4 | 11 =&gt; sdl2::pixels::Color::GREEN,
       5 | 12 =&gt; sdl2::pixels::Color::BLUE,
       6 | 13 =&gt; sdl2::pixels::Color::MAGENTA,
       7 | 14 =&gt; sdl2::pixels::Color::YELLOW,
       _ =&gt; sdl2::pixels::Color::CYAN,
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can transform CPU screen map into 3 bytes like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    let color_idx = cpu.mem_read(i as u16);
    let (b1, b2, b3) = color(color_idx).rgb();
<span class="boring">}
</span></code></pre></pre>
<p>Another caveat is that we don't want to force updating the SDL canvas if the screen state hasn't changed. 
Remember that the CPU would call our callback after each instruction, and most of the time, those instructions have nothing to do with the screen. Meantime, updating canvas is a heavy operation.</p>
<p>We can keep track of the screen state by creating a temp buffer that will be populated from the screen state. And only in case of screen changes, we would update SDL canvas.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn read_screen_state(cpu: &amp;CPU, frame: &amp;mut [u8; 32 * 3 * 32]) -&gt; bool {
   let mut frame_idx = 0;
   let mut update = false;
   for i in 0x0200..0x600 {
       let color_idx = cpu.mem_read(i as u16);
       let (b1, b2, b3) = color(color_idx).rgb();
       if frame[frame_idx] != b1 || frame[frame_idx + 1] != b2 || frame[frame_idx + 2] != b3 {
           frame[frame_idx] = b1;
           frame[frame_idx + 1] = b2;
           frame[frame_idx + 2] = b3;
           update = true;
       }
       frame_idx += 3;
   }
   update
}
<span class="boring">}
</span></code></pre></pre>
<p>And the game loop becomes:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
// ...init sdl
// ...load program

   let mut screen_state = [0 as u8; 32 * 3 * 32];
   let mut rng = rand::thread_rng();
 
   cpu.run_with_callback(move |cpu| {
       handle_user_input(cpu, &amp;mut event_pump);
       cpu.mem_write(0xfe, rng.gen_range(1, 16));
 
       if read_screen_state(cpu, &amp;mut screen_state) {
           texture.update(None, &amp;screen_state, 32 * 3).unwrap();
           canvas.copy(&amp;texture, None, None).unwrap();
           canvas.present();
       }
 
       ::std::thread::sleep(std::time::Duration::new(0, 70_000));
   });
}
</code></pre></pre>
<p>The last sleep statement was added to slow things down to have a playable pace. </p>
<p>And there you have it, the first game running on our emulator.</p>
<div style="text-align:center"><img src="./images/ch3/snk_game.gif" width="40%"/></div>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch3.4" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#emulating-bus" id="emulating-bus">Emulating BUS</a></h1>
<div style="text-align:center"><img src="./images/ch4/image_1_bus_schema.png" width="60%"/></div>
<p>CPU gets access to memory (including memory-mapped spaces) using three buses:</p>
<ul>
<li>address bus carries the address of a required location</li>
<li>control bus notifies if it's a read or write access</li>
<li>data bus carries the byte of data being read or written</li>
</ul>
<p>The bus itself is not a device; it's a wiring between platform components. 
And we don't need to implement it as an independent module as rust allows us to wire components directly. 
However, it's a convenient abstraction where we can offload quite a bit of responsibility to keep the CPU code cleaner. </p>
<div style="text-align:center"><img src="./images/ch4/image_2_cpu_pinout_2.png" width="50%"/></div>
<p>In our current code, the CPU has direct access to RAM space, and it is oblivious to memory-mapped regions. </p>
<p>By introducing Bus module, we can have a single place for:</p>
<ul>
<li>Intra device communication:
<ul>
<li>Data reads/writes</li>
<li>Routing hardware interrupts to CPU (more on this later)</li>
</ul>
</li>
<li>Handling memory mappings</li>
<li>Coordinating PPU and CPU clock cycles (more on this later)</li>
</ul>
<p>The good news is that we don't need to write full-blown emulation of data, control, and address buses. Because it's not a hardware chip, no logic expects any specific behavior from the BUS. So we can just codify coordination and signal routing. </p>
<p>For now, we can implement the bare bones of it:</p>
<ul>
<li>Access to CPU RAM</li>
<li>Mirroring </li>
</ul>
<p>Mirroring is a side-effect of NES trying to keep things as cheap as possible. It can be seen as an address space being mapped to another address space. </p>
<p>For instance, on a CPU memory map RAM address space <strong>[0x000 .. 0x0800]</strong> (2 KiB) is mirrored three times:</p>
<ul>
<li><strong>[0x800 .. 0x1000]</strong></li>
<li><strong>[0x1000 .. 0x1800]</strong></li>
<li><strong>[0x1800 .. 0x2000]</strong></li>
</ul>
<p>This means that there is no difference in accessing memory addresses at 0x0000 or 0x0800 or 0x1000 or 0x1800 for reads or writes. </p>
<p>The reason for mirroring is in the fact that CPU RAM has only 2 KiB of ram space, and only 11 bits is enough for addressing RAM space. Naturally, the NES motherboard had only 11 addressing tracks from CPU to RAM.</p>
<div style="text-align:center"><img src="./images/ch4/image_3_cpu_ram_connection.png" width="70%"/></div>
<p>CPU however has <strong>[0x0000 - 0x2000]</strong> addressing space reserved for RAM space - and that's 13 bits. As a result, the 2 highest bits have no effect when accessing RAM. 
Another way of saying this, when CPU is requesting address at <strong>0b0001_1111_1111_1111</strong> (13 bits) the RAM chip would receive only <strong>0b11_1111_1111</strong> (11 bits) via the address bus. </p>
<p>So despite mirroring looking wasteful, it was a side-effect of the wiring, and on real hardware it cost nothing. Emulators, on the other hand, have to do extra work to provide the same behavior. </p>
<p>Long story short, the BUS needs to zero out the highest 2 bits if it receives a request in the range of <strong>[0x0000 … 0x2000]</strong></p>
<p>Similarly address space <strong>[0x2008 .. 0x4000]</strong> mirrors memory mapping for PPU registers <strong>[0x2000 .. 0x2008]</strong>. Those are the only two mirrorings the BUS would be responsible for. Let's codify it right away, even though we don't have anything for PPU yet.</p>
<p>So let's introduce a new module Bus, that will have direct access to RAM.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Bus {
   cpu_vram: [u8; 2048]
}
 
impl Bus {
   pub fn new() -&gt; Self{
       Bus {
           cpu_vram: [0; 2048]
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>And it would provide read/write access:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const RAM: u16 = 0x0000;
const RAM_MIRRORS_END: u16 = 0x1FFF;
const PPU_REGISTERS: u16 = 0x2000;
const PPU_REGISTERS_MIRRORS_END: u16 = 0x3FFF;
 
impl Mem for Bus {
   fn mem_read(&amp;self, addr: u16) -&gt; u8 {
       match addr {
           RAM ..= RAM_MIRRORS_END =&gt; {
               let mirror_down_addr = addr &amp; 0b00000111_11111111;
               self.cpu_vram[mirror_down_addr as usize]
           }
           PPU_REGISTERS ..= PPU_REGISTERS_MIRRORS_END =&gt; {
               let _mirror_down_addr = addr &amp; 0b00100000_00000111;
               todo!(&quot;PPU is not supported yet&quot;)
           }
           _ =&gt; {
               println!(&quot;Ignoring mem access at {}&quot;, addr);
               0
           }
       }
   }
 
   fn mem_write(&amp;mut self, addr: u16, data: u8) {
       match addr {
           RAM ..= RAM_MIRRORS_END =&gt; {
               let mirror_down_addr = addr &amp; 0b11111111111;
               self.cpu_vram[mirror_down_addr as usize] = data;
           }
           PPU_REGISTERS ..= PPU_REGISTERS_MIRRORS_END =&gt; {
               let _mirror_down_addr = addr &amp; 0b00100000_00000111;
               todo!(&quot;PPU is not supported yet&quot;);
           }
           _ =&gt; {
               println!(&quot;Ignoring mem write-access at {}&quot;, addr);
           }
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>The last step is to replace direct access to RAM from CPU with access via BUS</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct CPU {
   pub register_a: u8,
   pub register_x: u8,
   pub register_y: u8,
   pub status: CpuFlags,
   pub program_counter: u16,
   pub stack_pointer: u8,
   pub bus: Bus,
}
 
 
impl Mem for CPU {
   fn mem_read(&amp;self, addr: u16) -&gt; u8 {
       self.bus.mem_read(addr)
   }
 
   fn mem_write(&amp;mut self, addr: u16, data: u8) {
       self.bus.mem_write(addr, data)
   }
   fn mem_read_u16(&amp;self, pos: u16) -&gt; u16 {
       self.bus.mem_read_u16(pos)
   }
 
   fn mem_write_u16(&amp;mut self, pos: u16, data: u16) {
       self.bus.mem_write_u16(pos, data)
   }
}

impl CPU {
   pub fn new() -&gt; Self {
       CPU {
           register_a: 0,
           register_x: 0,
           register_y: 0,
           stack_pointer: STACK_RESET,
           program_counter: 0,
           status: CpuFlags::from_bits_truncate(0b100100),
           bus: Bus::new(),
       }
   }
   // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>And that's pretty much it for now. Wasn't hard, right?</p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch4" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#cartridges" id="cartridges">Cartridges</a></h1>
<div style="text-align:center"><img src="./images/ch5/image_1_a_cartridge.png" width="20%"/></div>
<p>The first version of the cartridges was relatively simple. They carried two banks of ROM memory: PRG ROM for code and CHR ROM for visual graphics. </p>
<p>Upon insertion into the console, PRG ROM got connected to CPU, and CHR ROM got connected to PPU. So on a hardware level, CPU wasn't able to access CHR ROM directly, and PPU wasn't able to access PRG ROM. </p>
<blockquote>
<p>Later versions of cartridges had additional hardware: </p>
<ul>
<li>mappers to provide access to extended ROM memory: both CHR ROM and PRG ROM </li>
<li>extra RAM (with a battery) to save and restore a game state</li>
</ul>
</blockquote>
<p>However, we won't be working with cartridges. Emulators work with files containing dumps of ROM spaces.</p>
<p>There are several file formats for ROM dumps; the most popular one is iNES designed by <a href="http://fms.komkon.org">Marat Fayzullin</a></p>
<div style="text-align:center"><img src="./images/ch5/image_2_ines_file_format.png" width="60%"/></div>
<p>The file contains 3-4 sections:</p>
<ul>
<li>16-byte header</li>
<li>optional 512 of so-called Trainer, a data created by Famicom copiers to keep their own mapping. We can skip this section if it is present.</li>
<li>Section containing PRG ROM code</li>
<li>Section containing CHR ROM data</li>
</ul>
<p>The header is the most interesting part.</p>
<div style="text-align:center"><img src="./images/ch5/image_3_ines_header.png" width="60%"/></div>
<p>Control Byte 1 and Control Byte 2 (Byte 06 and 07 in the header) contain some additional info about the data in file, but it's packed in bits.</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><div style="text-align:center"><img src="./images/ch5/image_4_control_byte_1.png" width="100%"/></div></td><td><div style="text-align:center"><img src="./images/ch5/image_5_control_byte_2.png" width="100%"/></div></td></tr>
</tbody></table>
<br/>
We won't cover and support the iNES 2.0 format as it's not very popular. But you can find  <a href="https://formats.kaitai.io/ines/index.html">the formal specification of both iNES versions</a>.
<p>The bare minimum information we care about:</p>
<ul>
<li>PRG ROM</li>
<li>CHR ROM</li>
<li>Mapper type</li>
<li>Mirroring type: Horizontal, Vertical, 4 Screen</li>
</ul>
<p>Mirroring will be extensively covered in the following PPU chapters. 
For now, we need to figure out which mirroring type the game is using. </p>
<p>We would support only the iNES 1.0 format and mapper 0. </p>
<p>Mapper 0 essentially means &quot;no mapper&quot; that CPU reads both CHR and PRG ROM as is. </p>
<p>Let's define cartridge Rom data structure:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, PartialEq)]
pub enum Mirroring {
   VERTICAL,
   HORIZONTAL,
   FOUR_SCREEN,
}
 
pub struct Rom {
   pub prg_rom: Vec&lt;u8&gt;,
   pub chr_rom: Vec&lt;u8&gt;,
   pub mapper: u8,
   pub screen_mirroring: Mirroring,
}

<span class="boring">}
</span></code></pre></pre>
<p>Then we need to write the code to parse binary data:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Rom {
   pub fn new(raw: &amp;Vec&lt;u8&gt;) -&gt; Result&lt;Rom, String&gt; {
       if &amp;raw[0..4] != NES_TAG {
           return Err(&quot;File is not in iNES file format&quot;.to_string());
       }
 
       let mapper = (raw[7] &amp; 0b1111_0000) | (raw[6] &gt;&gt; 4);
 
       let ines_ver = (raw[7] &gt;&gt; 2) &amp; 0b11;
       if ines_ver != 0 {
           return Err(&quot;NES2.0 format is not supported&quot;.to_string());
       }
 
       let four_screen = raw[6] &amp; 0b1000 != 0;
       let vertical_mirroring = raw[6] &amp; 0b1 != 0;
       let screen_mirroring = match (four_screen, vertical_mirroring) {
           (true, _) =&gt; Mirroring::FOUR_SCREEN,
           (false, true) =&gt; Mirroring::VERTICAL,
           (false, false) =&gt; Mirroring::HORIZONTAL,
       };
 
       let prg_rom_size = raw[4] as usize * PRG_ROM_PAGE_SIZE;
       let chr_rom_size = raw[5] as usize * CHR_ROM_PAGE_SIZE;
 
       let skip_trainer = raw[6] &amp; 0b100 != 0;
 
       let prg_rom_start = 16 + if skip_trainer { 512 } else { 0 };
       let chr_rom_start = prg_rom_start + prg_rom_size;
 
       Ok(Rom {
           prg_rom: raw[prg_rom_start..(prg_rom_start + prg_rom_size)].to_vec(),
           chr_rom: raw[chr_rom_start..(chr_rom_start + chr_rom_size)].to_vec(),
           mapper: mapper,
           screen_mirroring: screen_mirroring,
       })
   }
}

<span class="boring">}
</span></code></pre></pre>
<p>As always, don't forget the tests!</p>
<p>Next, connect Rom to the BUS:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Bus {
   cpu_vram: [u8; 2048],
   rom: Rom,
}
 
impl Bus {
   pub fn new(rom: Rom) -&gt; Self {
       Bus {
           cpu_vram: [0; 2048],
           rom: rom,
       }
   }
   //....
}
<span class="boring">}
</span></code></pre></pre>
<p>And finally, we need to map address space <strong>[0x8000 … 0x10000]</strong> to cartridge PRG ROM space. </p>
<p>One caveat: PRG Rom Size might be 16 KiB or 32 KiB.
Because <strong>[0x8000 … 0x10000]</strong> mapped region is 32 KiB of addressable space, upper 16 KiB needs to be mapped to lower 16 KiB (if a game has only 16 KiB of PRG ROM)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Mem for Bus {
   fn mem_read(&amp;self, addr: u16) -&gt; u8 {
       match addr {
           //….
           0x8000..=0xFFFF =&gt; self.read_prg_rom(addr),
       }
   }
 
   fn mem_write(&amp;mut self, addr: u16, data: u8) {
       match addr {
           //...
           0x8000..=0xFFFF =&gt; {
               panic!(&quot;Attempt to write to Cartridge ROM space&quot;)
           }
       }
   }
}

impl Bus {
  // ...
 
   fn read_prg_rom(&amp;self, mut addr: u16) -&gt; u8 {
       addr -= 0x8000;
       if self.rom.prg_rom.len() == 0x4000 &amp;&amp; addr &gt;= 0x4000 {
           //mirror if needed
           addr = addr % 0x4000;
       }
       self.rom.prg_rom[addr as usize]
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can download your first NES ROM dump file on <a href="https://github.com/bugzmanov/nes_ebook/blob/master/code/ch5/snake.nes?raw=true">github</a>.</p>
<p>You would need to modify the <code>main</code> method to load binary from a file.</p>
<p>Spoiler alert: it's a modification of a snake game with more funk in physics. The game expects the same memory map for the input device, screen output, and random number generator. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch5" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#running-our-first-test-rom" id="running-our-first-test-rom">Running our first test ROM</a></h1>
<p>NES dev community has created <a href="https://wiki.nesdev.com/w/index.php/Emulator_tests">large suites of tests</a> that can be used to check our emulator. </p>
<p>They cover pretty much every aspect, including quirks and famous bugs that were embedded in the platform. </p>
<div style="text-align:center"><img src="./images/ch5.1/image_1_i_am_error.png" width="40%"/></div>
<p>We will start with the most basic test covering main CPU features: instruction set, memory access, and CPU cycles. </p>
<p>The iNES file of the test is located here: <a href="http://nickmass.com/images/nestest.nes">nestest.nes</a>
An execution log accompanies the test, showing how the execution should look like: <a href="https://www.qmtpro.com/%7Enes/misc/nestest.log">nestest.log</a></p>
<p>The next goal is to generate a similar execution log for the CPU while running a program.</p>
<div style="text-align:center"><img src="./images/ch5.1/image_2_log_structure.png" width="80%"/></div>
<p>For now, we can ignore the last column and focus on the first five. </p>
<p>The fourth column <code>@ 80 = 0200 = 00</code> is somewhat interesting. </p>
<ul>
<li>The first number is the actual mem reference that we get if we apply an offset to the requesting address. 0xE1 is using the &quot;Indirect X&quot; addressing mode, and the offset is defined by register X </li>
<li>The second number is a 2-byte target address fetched from <strong>[0x80 .. 0x81]</strong>. In this case it's [<em>0x00</em>, <em>0x02</em>]</li>
<li>The third number is content of address cell 0x0200</li>
</ul>
<p>We already have a place to intercept CPU execution: </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl CPU  {

// ..
    pub fn run_with_callback&lt;F&gt;(&amp;mut self, mut callback: F)
   where
       F: FnMut(&amp;mut CPU),
   {
       let ref opcodes: HashMap&lt;u8, &amp;'static opcodes::OpCode&gt; = *opcodes::OPCODES_MAP;
 
       loop {
           callback(self);
 // ...
      }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>All we need to do is to create a callback function that will trace CPU state:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
//...
    cpu.run_with_callback(move |cpu| {
       println!(&quot;{}&quot;, trace(cpu));
   }
}

</code></pre></pre>
<p>It's vital to get the execution log format precisely like the one used in the provided log.</p>
<p>Following tests can help you to get it right:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
   use super::*;
   use crate::bus::Bus;
   use crate::cartridge::test::test_rom;
 
   #[test]
   fn test_format_trace() {
       let mut bus = Bus::new(test_rom());
       bus.mem_write(100, 0xa2);
       bus.mem_write(101, 0x01);
       bus.mem_write(102, 0xca);
       bus.mem_write(103, 0x88);
       bus.mem_write(104, 0x00);
 
       let mut cpu = CPU::new(bus);
       cpu.program_counter = 0x64;
       cpu.register_a = 1;
       cpu.register_x = 2;
       cpu.register_y = 3;
       let mut result: Vec&lt;String&gt; = vec![];
       cpu.run_with_callback(|cpu| {
           result.push(trace(cpu));
       });
       assert_eq!(
           &quot;0064  A2 01     LDX #$01                        A:01 X:02 Y:03 P:24 SP:FD&quot;,
           result[0]
       );
       assert_eq!(
           &quot;0066  CA        DEX                             A:01 X:01 Y:03 P:24 SP:FD&quot;,
           result[1]
       );
       assert_eq!(
           &quot;0067  88        DEY                             A:01 X:00 Y:03 P:26 SP:FD&quot;,
           result[2]
       );
   }
 
   #[test]
   fn test_format_mem_access() {
       let mut bus = Bus::new(test_rom());
       // ORA ($33), Y
       bus.mem_write(100, 0x11);
       bus.mem_write(101, 0x33);
 
 
       //data
       bus.mem_write(0x33, 00);
       bus.mem_write(0x34, 04);
 
       //target cell
       bus.mem_write(0x400, 0xAA);
 
       let mut cpu = CPU::new(bus);
       cpu.program_counter = 0x64;
       cpu.register_y = 0;
       let mut result: Vec&lt;String&gt; = vec![];
       cpu.run_with_callback(|cpu| {
           result.push(trace(cpu));
       });
       assert_eq!(
           &quot;0064  11 33     ORA ($33),Y = 0400 @ 0400 = AA  A:00 X:00 Y:00 P:24 SP:FD&quot;,
           result[0]
       );
   }
}
 
<span class="boring">}
</span></code></pre></pre>
<p>Now it's time to compare our execution log with the golden standard.</p>
<pre><code class="language-bash">cargo run &gt; mynes.log
diff -y mynes.log nestest.log
</code></pre>
<blockquote>
<p>You can use any diff tool you'd like. But because our NES doesn't support CPU clock cycles yet, it makes sense to remove last columns in the provided log:</p>
<pre><code class="language-bash">cat nestest.log | awk '{print substr($0,0, 73)}' &gt; nestest_no_cycle.log
diff -y mynes.log nestest_no_cycle.log
</code></pre>
</blockquote>
<p>If everything is OK, the first mismatch should look like this:</p>
<pre><code>C6B3  A9 AA     LDA #$AA                        A:FF X:97 Y:4   C6B3  A9 AA     LDA #$AA                        A:FF X:97 Y:4
C6B5  D0 05     BNE $C6BC                       A:AA X:97 Y:4   C6B5  D0 05     BNE $C6BC                       A:AA X:97 Y:4
C6BC  28        PLP                             A:AA X:97 Y:4   C6BC  28        PLP                             A:AA X:97 Y:4
                                                              &gt; C6BD  04 A9    *NOP $A9 = 00                    A:AA X:97 Y:4
</code></pre>
<p>I.e., everything that our emulator has produced should exactly match the golden standard, up to line <strong>0xC6BC</strong>. If anything is off before the line, we have a mistake in our CPU implementation. And it needs to be fixed.</p>
<p>But that doesn't explain why our program got terminated. Why didn't we get the perfect match after the line <strong>0xC6BC</strong>?</p>
<p>The program has failed at </p>
<pre><code class="language-bash">C6BD  04 A9    *NOP $A9 = 00
</code></pre>
<p>It looks like our CPU doesn't know how to interpret opcode 0x04. </p>
<p>Here is the bad news: there are about 110 unofficial CPU instructions. And most of the real NES games do use them a lot. For us to move on, we would need to implement all of them. </p>
<p>The specs can be found here:</p>
<ul>
<li><a href="http://nesdev.com/undocumented_opcodes.txt">nesdev.com/undocumented_opcodes.txt</a></li>
<li><a href="https://wiki.nesdev.com/w/index.php/Programming_with_unofficial_opcodes">wiki.nesdev.com/w/index.php/Programming_with_unofficial_opcodes</a></li>
<li><a href="https://wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes">wiki.nesdev.com/w/index.php/CPU_unofficial_opcodes</a></li>
<li><a href="http://www.oxyron.de/html/opcodes02.html">www.oxyron.de/html/opcodes02.html</a></li>
</ul>
<p>Remember how to draw an owl? ) </p>
<p>The testing ROM should drive your progress. In the end, the CPU should support 256 instructions. Considering that 1 byte is for the operation code, we've exhausted all possible values. </p>
<p>Finally, the first mismatch should happen on this line:</p>
<pre><code class="language-bash">C68B  8D 15 40  STA $4015 = FF                  A:02 X:FF Y:15 P:25 SP:FB
</code></pre>
<p>almost at the very end of the NES test log file. </p>
<p>That's a good sign. 4015 is a memory map for the APU register. And we don't have that implemented yet. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch5.1" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#emulating-picture-processing-unit" id="emulating-picture-processing-unit">Emulating Picture Processing Unit</a></h1>
<p>Picture Processing Unit is the hardest one to emulate. Because it deals with the most complicated aspect of gaming - rendering the state of the screen, but also NES PPU has quite a bit of quirks. While emulating some of them is not necessarily required, others are crucially important to have a playable environment. 
64KiB is not a hell lot of space, and NES platform designers tried to squeeze out of it as much as possible. Working with CHR ROM data means pretty much working with compressed data format; it requires a lot of bit arithmetic, uncompressing, and parsing.</p>
<div style="text-align:center"><img src="./images/ch6/image_1_ppu_failures.png" width="60%"/></div>
<p>We would create the PPU emulator using four main steps:</p>
<ul>
<li>Emulating Registers and NMI Interruption</li>
<li>Parsing and drawing tiles from CHR ROM</li>
<li>Rendering PPU state: 
<ul>
<li>Rendering background tiles </li>
<li>Rendering sprites</li>
</ul>
</li>
<li>Implementing the scroll</li>
</ul>
<p>The first step is very similar to emulating the CPU. 
After the third one it will be possible to play games with static screens:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Pac-Man">PacMan</a></li>
<li><a href="https://en.wikipedia.org/wiki/Donkey_Kong">Donkey Kong</a></li>
<li><a href="https://en.wikipedia.org/wiki/Balloon_Fight">Baloon Fight</a></li>
</ul>
<p>When we are done with the scroll, we could play platformers like <a href="https://en.wikipedia.org/wiki/Super_Mario_Bros">Super Mario Bros</a>. </p>
<p>So let's start.</p>
<h1><a class="header" href="#emulating-ppu-registers" id="emulating-ppu-registers">Emulating PPU Registers</a></h1>
<p>PPU has its own memory map, composed of PPU RAM, CHR ROM, and address space mirrors.
PPU exposes 8 IO Registers that are used by the CPU for communication. Those registers are mapped to <strong>[0x2000 - 0x2007]</strong> CPU memory map (and mirrored every 8 bytes through the region of <strong>[0x2008 .. 0x3FFF]</strong>)</p>
<div style="text-align:center"><img src="./images/ch6.1/image_1_ppu_registers_memory.png" width="70%"/></div>
<p>To be precise, PPU has its own bus used to communicate with RAM and cartridge CHR ROM. But we don't necessarily need to emulate that. </p>
<p>2 registers are responsible for accessing PPU memory map:</p>
<ul>
<li>Address (0x2006) &amp; Data (0x2006) - provide access to the memory map available for PPU</li>
</ul>
<p>3 registers control internal memory(OAM) that keeps the state of sprites</p>
<ul>
<li>OAM Address (0x2003) &amp; OAM Data (0x2004)  - Object Attribute Memory - the space responsible for sprites</li>
<li>Direct Memory Access (0x4014) - for fast copying of 256 bytes from CPU RAM to OAM </li>
</ul>
<p>3 Write-only registers are controlling PPU actions:</p>
<ul>
<li>Controller (0x2000) - instructs PPU on general logic flow (which mem table to use, if PPU should interrupt CPU, etc.)</li>
<li>Mask (0x2001) - instructs PPU how to render sprites and background</li>
<li>Scroll (0x2005) - instructs PPU how to set a viewport</li>
</ul>
<p>One read-only register is used for reporting PPU status:</p>
<ul>
<li>Status 0x2002</li>
</ul>
<p>The full spec of the registers can be found on <a href="http://wiki.nesdev.com/w/index.php/PPU_registers">NES Dev wiki</a></p>
<div style="text-align:center"><img src="./images/ch6.1/image_2_cpu_ppu_communication.png" width="70%"/></div>
<p>Two communication channels exist between CPU and PPU:</p>
<ul>
<li>CPU is driving communication through IO registers</li>
<li>PPU sends an interrupt signal to CPU upon entering V-BLANK period</li>
</ul>
<blockquote>
<p>PPU execution lifecycle was tightly coupled with the electron beam of the TV screen. </p>
<p>The PPU renders 262 scanlines per frame. (0 - 240 are visible scanlines, the rest are so-called vertical overscan)<br/>
Each scanline lasts for 341 PPU clock cycles, with each clock cycle producing one pixel. (the first 256 pixels are visible, the rest is horizontal overscal)<br/>
The NES screen resolution is 320x240, thus scanlines 241 - 262 are not visible. </p>
<div style="text-align:center"><img src="./images/ch6.1/image_7_scanlines_with_viewer.png" width="30%"/></div>
Upon entering the 241st scanline, PPU triggers VBlank NMI on the CPU. PPU makes no memory accesses during 241-262 scanlines, so PPU memory can be freely accessed by the program. The majority of games play it safe and update the screen state only during this period, essentially preparing the view state for the next frame. 
</blockquote>
<h2><a class="header" href="#ppu-sketch" id="ppu-sketch">PPU sketch</a></h2>
<p>Initial sketch of out PPU would look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct NesPPU {
   pub chr_rom: Vec&lt;u8&gt;,
   pub palette_table: [u8; 32],
   pub vram: [u8; 2048],
   pub oam_data: [u8; 256],

   pub mirroring: Mirroring,
}
<span class="boring">}
</span></code></pre></pre>
<p>Where </p>
<ul>
<li><strong>chr_rom</strong> -  visuals of a game stored on a cartridge</li>
<li><strong>palette_table</strong> - internal memory to keep palette tables used by a screen</li>
<li><strong>vram</strong> - 2 KiB banks of space to hold background information</li>
<li>and <strong>oam_data</strong> - internal memory to keep state of sprites.</li>
</ul>
<p>mirroring and chr_rom are specific to each game and provided by a cartridge</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl NesPPU {
   pub fn new(chr_rom: Vec&lt;u8&gt;, mirroring: Mirroring) -&gt; Self {
       NesPPU {
           chr_rom: chr_rom,
           mirroring: mirroring,
           vram: [0; 2048],
           oam_data: [0; 64 * 4],
           palette_table: [0; 32],
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#emulating-ppu-memory-access-address-and-data-registers" id="emulating-ppu-memory-access-address-and-data-registers">Emulating PPU memory access: Address and Data registers</a></h2>
<p>Let's try to emulate two the most complex registers: Address (<strong>0x2006</strong>) and Data(<strong>0x2007</strong>)</p>
<p>There are multiple caveats in the way the CPU can access PPU RAM. Say, CPU wants to access mem cell at 0x0600 PPU memory space:</p>
<ol>
<li>It has to load the requesting address into the Addr register. It has to write to the register twice - to load 2 bytes into 1-byte register:<br/><br/> </li>
</ol>
<pre><code class="language-bash"> LDA #$06
 STA $2006
 LDA #$00
 STA $2006
</code></pre>
<p>Note: it <strong>doesn't</strong> follow <em>little-endian</em> notation. </p>
<ol start="2">
<li>Then, the CPU can request data load from PPU Data register (0x2007)</li>
</ol>
<pre><code class="language-bash">LDA $2007
</code></pre>
<blockquote>
<p>Because CHR ROM and RAM are considered external devices to PPU, PPU can't return the value immediately. PPU has to fetch the data and keep it in internal buffer.<br/> 
The first read from 0x2007 would return the content of this internal buffer filled during the previous load operation. From the CPU perspective, this is a dummy read. </p>
</blockquote>
<ol start="3">
<li>CPU has to read from 0x2007 one more time to finally get the value from the PPUs internal buffer. </li>
</ol>
<pre><code class="language-bash">LDA $2007
</code></pre>
<blockquote>
<p>Also note that read or write access to 0x2007 increments the PPU Address (0x2006). The increment size is determined by the state of the Control register (0x2000):</p>
<div style="text-align:left"><img src="./images/ch6.1/image_3_controller_register_spec.png" width="60%"/></div>
</blockquote>
<p>The sequence of requests can be illustrated in this diagram:</p>
<div style="text-align:center"><img src="./images/ch6.1/image_4_ppu_ram_sequence.png" width="60%"/></div>
<blockquote>
<p><strong>IMPORTANT:</strong> This buffered reading behavior is specific only to ROM and RAM. <br/>
Reading palette data from $3F00-$3FFF works differently. The palette data is placed immediately on the data bus, and hence no dummy read is required.</p>
</blockquote>
<p>Lets model Address register first:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct AddrRegister {
   value: (u8, u8),
   hi_ptr: bool,
}
 
impl AddrRegister {
   pub fn new() -&gt; Self {
       AddrRegister {
           value: (0, 0), // high byte first, lo byte second
           hi_ptr: true,
       }
   }
   fn set(&amp;mut self, data: u16) {
       self.value.0 = (data &gt;&gt; 8) as u8;
       self.value.1 = (data &amp; 0xff) as u8;
   }
 
   pub fn update(&amp;mut self, data: u8) {
       if self.hi_ptr {
           self.value.0 = data;
       } else {
           self.value.1 = data;
       }
 
       if self.get() &gt; 0x3fff { //mirror down addr above 0x3fff
           self.set(self.get() &amp; 0b11111111111111);
       }
       self.hi_ptr = !self.hi_ptr;
   }
 
   pub fn increment(&amp;mut self, inc: u8) {
       let lo = self.value.1;
       self.value.1 = self.value.1.wrapping_add(inc);
       if lo &gt; self.value.1 {
           self.value.0 = self.value.0.wrapping_add(1);
       }
       if self.get() &gt; 0x3fff {
           self.set(self.get() &amp; 0b11111111111111); //mirror down addr above 0x3fff
       }
   }
 
   pub fn reset_latch(&amp;mut self) {
       self.hi_ptr = true;
   }
 
   pub fn get(&amp;self) -&gt; u16 {
       ((self.value.0 as u16) &lt;&lt; 8) | (self.value.1 as u16)
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we need to expose this register as being writable:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct NesPPU {
   //...
   addr: AddrRegister,
}

impl NesPPU {
// ...
   fn write_to_ppu_addr(&amp;mut self, value: u8) {
       self.addr.update(value);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we can sketch out Controller Register: </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>bitflags! {
 
   // 7  bit  0
   // ---- ----
   // VPHB SINN
   // |||| ||||
   // |||| ||++- Base nametable address
   // |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
   // |||| |+--- VRAM address increment per CPU read/write of PPUDATA
   // |||| |     (0: add 1, going across; 1: add 32, going down)
   // |||| +---- Sprite pattern table address for 8x8 sprites
   // ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
   // |||+------ Background pattern table address (0: $0000; 1: $1000)
   // ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels)
   // |+-------- PPU master/slave select
   // |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
   // +--------- Generate an NMI at the start of the
   //            vertical blanking interval (0: off; 1: on)
   pub struct ControlRegister: u8 {
       const NAMETABLE1              = 0b00000001;
       const NAMETABLE2              = 0b00000010;
       const VRAM_ADD_INCREMENT      = 0b00000100;
       const SPRITE_PATTERN_ADDR     = 0b00001000;
       const BACKROUND_PATTERN_ADDR  = 0b00010000;
       const SPRITE_SIZE             = 0b00100000;
       const MASTER_SLAVE_SELECT     = 0b01000000;
       const GENERATE_NMI            = 0b10000000;
   }
}
 
impl ControlRegister {
   pub fn new() -&gt; Self {
       ControlRegister::from_bits_truncate(0b00000000)
   }
 
   pub fn vram_addr_increment(&amp;self) -&gt; u8 {
       if !self.contains(ControlRegister::VRAM_ADD_INCREMENT) {
           1
       } else {
           32
       }
   }
 
   pub fn update(&amp;mut self, data: u8) {
       self.bits = data;
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>And also expose it as being writable:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct NesPPU {
   pub ctrl: ControlRegister,
   //...
}
 
impl NesPPU {
   //...
   fn write_to_ctrl(&amp;mut self, value: u8) {
       self.ctrl.update(value);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can try to implement reading PPU memory:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl NesPPU {
   //...
   fn increment_vram_addr(&amp;mut self) {
       self.addr.increment(self.ctrl.vram_addr_increment());
   }
 
 
   fn read_data(&amp;mut self) -&gt; u8 {
       let addr = self.addr.get();
       self.increment_vram_addr();
 
 
 
       match addr {
           0..=0x1fff =&gt; todo!(&quot;read from chr_rom&quot;),
           0x2000..=0x2fff =&gt; todo!(&quot;read from RAM&quot;),
           0x3000..=0x3eff =&gt; panic!(&quot;addr space 0x3000..0x3eff is not expected to be used, requested = {} &quot;, addr),
           0x3f00..=0x3fff =&gt;
           {
               self.palette_table[(addr - 0x3f00) as usize]
           }
           _ =&gt; panic!(&quot;unexpected access to mirrored space {}&quot;, addr),
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>We can emulate this internal buffer behavior for RAM and ROM by using a temporary field to hold a value from a previous read request:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>pub struct NesPPU {
    //..
    internal_data_buf: u8,
}

impl NesPPU {
 // ...

    fn read_data(&amp;mut self) -&gt; u8 {
        let addr = self.addr.get();
        self.increment_vram_addr();

        match addr {
            0..=0x1fff =&gt; {
                let result = self.internal_data_buf;
                self.internal_data_buf = self.chr_rom[addr as usize];
                result
            }
            0x2000..=0x2fff =&gt; {
                let result = self.internal_data_buf;
                self.internal_data_buf = self.vram[self.mirror_vram_addr(addr) as usize];
                result
            }
            // ..
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Writing to PPU memory can be implemented similarly, just don't forget that writes to 0x2007 also increments Address Register.</p>
<h2><a class="header" href="#mirroring" id="mirroring">Mirroring</a></h2>
<p>One thing that isn't covered is how <code>mirror_vram_addr</code> is implemented. </p>
<p>Again the NESDEV wiki provides excellent coverage of this topic: <a href="http://wiki.nesdev.com/w/index.php/Mirroring">Mirroring</a>.</p>
<p>VRAM mirroring is tightly coupled with the way NES implements scrolling of the viewport.
We would spend enough time discussing this in the chapter about Scroll. 
For now, we can just codify mirroring behavior.</p>
<p>NES uses 1 KiB of VRAM to represent a single screen state. Having 2 KiB of VRAM onboard means that NES can keep a state of 2 screens.</p>
<p>On the PPU memory map, the range <em><strong>[0x2000...0x3F00]</strong></em> is reserved for Nametables (screens states)- 4 KiB of addressable space. Two &quot;additional&quot; screens have to be mapped to existing ones.
The way they are mapped depends on the mirroring type, specified by a game (iNES files have this info in the header) </p>
<div style="text-align:center"><img src="./images/ch6.1/image_5_mirroring.png" width="60%"/></div>
<p>For example, for <em>Horizontal Mirroring</em>: </p>
<ul>
<li>Address spaces <strong>[0x2000 .. 0x2400]</strong> and <strong>[0x2400 .. 0x2800]</strong> should be mapped to the first 1 KiB of VRAM. </li>
<li>Address spaces <strong>[0x2800 .. 0x2C00]</strong> and <strong>[0x2C00 .. 0x3F00]</strong> should be mapped to the second 1 KiB of VRAM.</li>
</ul>
<p>One way to codify that:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl NesPPU {
   //...  
 
   // Horizontal:
   //   [ A ] [ a ]
   //   [ B ] [ b ]
 
   // Vertical:
   //   [ A ] [ B ]
   //   [ a ] [ b ]
   pub fn mirror_vram_addr(&amp;self, addr: u16) -&gt; u16 {
       let mirrored_vram = addr &amp; 0b10111111111111; // mirror down 0x3000-0x3eff to 0x2000 - 0x2eff
       let vram_index = mirrored_vram - 0x2000; // to vram vector
       let name_table = vram_index / 0x400; // to the name table index
       match (&amp;self.mirroring, name_table) {
           (Mirroring::VERTICAL, 2) | (Mirroring::VERTICAL, 3) =&gt; vram_index - 0x800,
           (Mirroring::HORIZONTAL, 2) =&gt; vram_index - 0x400,
           (Mirroring::HORIZONTAL, 1) =&gt; vram_index - 0x400,
           (Mirroring::HORIZONTAL, 3) =&gt; vram_index - 0x800,
           _ =&gt; vram_index,
       }
   }
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#connecting-ppu-to-the-bus" id="connecting-ppu-to-the-bus">Connecting PPU to the BUS</a></h2>
<p>One last step is to connect PPU to the BUS:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Bus {
    cpu_vram: [u8; 2048],
    prg_rom: Vec&lt;u8&gt;,
    ppu: NesPPU
}

impl Bus {
    pub fn new(rom: Rom) -&gt; Self {
        let ppu = NesPPU::new(rom.chr_rom, rom.screen_mirroring);

        Bus {
            cpu_vram: [0; 2048],
            prg_rom: rom.prg_rom,
            ppu: ppu,
        }
    }
//..

}
<span class="boring">}
</span></code></pre></pre>
<p>And provide memory mapping for the registers we've implemented so far:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>impl Bus {
    //...
    fn mem_read(&amp;mut self, addr: u16) -&gt; u8 {
        match addr {
            RAM..=RAM_MIRRORS_END =&gt; {
                let mirror_down_addr = addr &amp; 0b00000111_11111111;
                self.cpu_vram[mirror_down_addr as usize]
            }
            0x2000 | 0x2001 | 0x2003 | 0x2005 | 0x2006 | 0x4014 =&gt; {
                panic!(&quot;Attempt to read from write-only PPU address {:x}&quot;, addr);
            }
            0x2007 =&gt; self.ppu.read_data(),

            0x2008..=PPU_REGISTERS_MIRRORS_END =&gt; {
                let mirror_down_addr = addr &amp; 0b00100000_00000111;
                self.mem_read(mirror_down_addr)
            }
            0x8000..=0xFFFF =&gt; self.read_prg_rom(addr),

            _ =&gt; {
                println!(&quot;Ignoring mem access at {}&quot;, addr);
                0
            }
        }
    }

    fn mem_write(&amp;mut self, addr: u16, data: u8) {
        match addr {
            RAM..=RAM_MIRRORS_END =&gt; {
                let mirror_down_addr = addr &amp; 0b11111111111;
                self.cpu_vram[mirror_down_addr as usize] = data;
            }
            0x2000 =&gt; {
                self.ppu.write_to_ctrl(data);
            }

            0x2006 =&gt; {
                self.ppu.write_to_ppu_addr(data);
            }
            0x2007 =&gt; {
                self.ppu.write_to_data(data);
            }

            0x2008..=PPU_REGISTERS_MIRRORS_END =&gt; {
                let mirror_down_addr = addr &amp; 0b00100000_00000111;
                self.mem_write(mirror_down_addr, data);
            }
            0x8000..=0xFFFF =&gt; panic!(&quot;Attempt to write to Cartridge ROM space: {:x}&quot;, addr),

            _ =&gt; {
                println!(&quot;Ignoring mem write-access at {}&quot;, addr);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The communication with the rest of the registers is similar. And I leave this exercise to the reader. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch6.1" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#emulating-interrupts" id="emulating-interrupts">Emulating Interrupts</a></h1>
<p>Interrupts are the mechanism for the CPU to break the sequential execution flow and react to events that require immediate attention (&quot;attend to an interrupt&quot;).</p>
<p>We've already implemented one of the supported interrupts - RESET signal. This interrupt notifies the CPU that a new cartridge was inserted and the CPU needs to execute the reset subroutine.</p>
<div style="text-align:center"><img src="./images/ch6.2/image_4_broadcast_interrupted.png" width="30%"/></div>
<p>PPU communicates that it's entering the VBLANK phase for the frame via another interrupt signal - NMI (Non-Maskable Interrupt). 
From a high-level perspective, this means two things:</p>
<ul>
<li>PPU is done rendering the current frame</li>
<li>CPU can safely access PPU memory to update the state for the next frame.</li>
</ul>
<blockquote>
<p>The reason why VBLANK phase is unique is that while PPU is rendering visible scan lines, it's constantly using internal buffers and memory. External access to IO registers can corrupt data in those buffers and cause noticeable graphic glitches. </p>
</blockquote>
<p>Unlike other interrupts, CPU can't ignore the NMI. And the <strong>Disable Interrupt</strong> flag in the <strong>Status register P</strong> has no effect on how the CPU attends to it.
The CPU however, might instruct PPU to not trigger NMI by resetting the 7th bit in the PPU Control register. </p>
<h2><a class="header" href="#clock-cycles" id="clock-cycles">Clock cycles</a></h2>
<p>The NMI interrupt is tightly connected to PPU clock cycles:</p>
<ul>
<li>the PPU renders 262 scan lines per frame. </li>
<li>each scanline lasts for 341 PPU clock cycles </li>
<li>upon entering scanline 241, PPU triggers NMI interrupt</li>
<li>PPU clock cycles are 3 times faster than CPU clock cycles</li>
</ul>
<p>Nothing beats NESDev wiki in providing <a href="http://wiki.nesdev.com/w/index.php/PPU_rendering#Line-by-line_timing">details on line-by-line timing</a></p>
<p>But to simplify, </p>
<ul>
<li>each PPU frame takes <code>341*262=89342 PPU clocks cycles</code></li>
<li>CPU is guaranteed to receive NMI every interrupt <code>~29780 CPU cycles</code></li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> PPU Cycles and CPU Cycles are not the same things</p>
</blockquote>
<p>On the NES Platform, all components were running independently in parallel. This makes NES a distributed system. The coordination hast to be carefully designed by game developers based on timing specs of the instructions. I can only imagine how tedious this manual process is. </p>
<p>The emulator can take multiple approaches to simulate this behavior:</p>
<ol>
<li>
<p>Allocate a thread per component and simulate proper timing for each instruction. I don't know any emulator that does that. Simulating proper timing is a hell of a task. Second, this approach requires allocating more hardware resources than needed for the job (PPU, CPU, and APU would require 3 threads, and potentially would occupy 3 cores on the host machine)</p>
</li>
<li>
<p>Execute all components sequentially in one thread, by advancing one clock cycle at a time in each component. This is similar to creating a green-thread runtime and using one dedicated OS thread to run this runtime. It would require substantial investment in creating green-threads runtime. </p>
</li>
<li>
<p>Execute all components sequentially in one thread, but by letting CPU to execute one full instruction, compute the clock cycles budget for other components and let them run within the budget. This technique is called <a href="http://wiki.nesdev.com/w/index.php/Catch-up">&quot;catch-up&quot;</a> <br/> <br/>For example, CPU takes 2 cycles to execute &quot;LDA #$01&quot; (opcode 0xA9), which means that PPU can run for 6 PPU cycles now (PPU clock is ticking three times faster than CPU clock) and APU can run for 1 cycle (APU clock is two times slower)</p>
</li>
</ol>
<p>Because we already have CPU loop mostly spec'd out, the third approach would be the easiest to implement. Granted, it would be the least accurate one. But it's good enough to have something playable as soon as possible.</p>
<p>So the flow would look like this: </p>
<div style="text-align:center"><img src="./images/ch6.2/image_1_tick_flow.png" width="60%"/></div>
<p>Starting from the CPU:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl CPU {
   pub fn run_with_callback&lt;F&gt;(&amp;mut self, mut callback: F)
   where
       F: FnMut(&amp;mut CPU),
   {
      //...
       loop {
        // …
           self.bus.tick(opcode.cycles);
 
           if program_counter_state == self.program_counter {
               self.program_counter += (opcode.len - 1) as u16;
           }
   }
 
   }
}

<span class="boring">}
</span></code></pre></pre>
<p>The Bus should keep track of executed cycles and propagate tick call to PPU, but because PPU clock is 3 times faster than CPU clock, it would multiply the value:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Bus {
   cpu_vram: [u8; 2048],
   prg_rom: Vec&lt;u8&gt;,
   ppu: NesPPU,
 
   cycles: usize,
}
 
impl Bus {
   pub fn new(rom: Rom) -&gt; Self {
       let ppu = NesPPU::new(rom.chr_rom, rom.screen_mirroring);
 
       Bus {
           cpu_vram: [0; 2048],
           prg_rom: rom.prg_rom,
           ppu: ppu,
           cycles: 0,
       }
   }
   pub fn tick(&amp;mut self, cycles: u8) {
       self.cycles += cycles as usize;
       self.ppu.tick(cycles * 3);
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>The PPU would track cycles and calculate which scanline is should be drawing:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct NesPPU {
   // ...
   scanline: u16,
   cycles: usize,
}
 
 
 
impl NesPPU {
// …
   pub fn tick(&amp;mut self, cycles: u8) -&gt; bool {
       self.cycles += cycles as usize;
       if self.cycles &gt;= 341 {
           self.cycles = self.cycles - 341;
           self.scanline += 1;
 
           if self.scanline == 241 {
               if self.ctrl.generate_vblank_nmi() {
                   self.status.set_vblank_status(true);
                   todo!(&quot;Should trigger NMI interrupt&quot;)
               }
           }
 
           if self.scanline &gt;= 262 {
               self.scanline = 0;
               self.status.reset_vblank_status();
               return true;
           }
       }
       return false;
   }
}

<span class="boring">}
</span></code></pre></pre>
<p>Some crucial details are still missing: some of the CPU operations take variable clock time depending on the execution flow. 
For example, conditional branch operations (like BNE) take an additional CPU cycle if the comparison is successful. And yet another CPU cycle if the JUMP would result in program counter to be on another memory page</p>
<blockquote>
<p>Memory page size is 256 bytes. For example, the range [0x0000 .. 0x00FF]- belongs to page 0, [0x0100 .. 0x01FF] belongs to page 1, etc.
It's enough to compare the upper byte of the addresses to see if they are on the same page. </p>
</blockquote>
<p>I leave it up to the reader to figure out how to codify those additional ticks that may or may not happen. </p>
<h1><a class="header" href="#interrupts" id="interrupts">Interrupts</a></h1>
<p>So far our dependency graph looks one-directional:</p>
<div style="text-align:center"><img src="./images/ch6.2/image_2_components_dag.png" width="60%"/></div>
<p>The problem is that we want to deliver signals from PPU to CPU and Rust doesn't really allow to have dependency cycles easily. </p>
<p>One way to overcome this is to replace the push model with pull. The CPU can ask if there are interrupts ready at the beginning of the interpret cycle. </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl CPU {
//...
   pub fn run_with_callback&lt;F&gt;(&amp;mut self, mut callback: F)
   where
       F: FnMut(&amp;mut CPU),
   {
       // ...
       loop {
           if let Some(_nmi) = self.bus.poll_nmi_status() {
               self.interrupt_nmi();
           } 
           // …
       }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The final piece is to implement interrupt behavior.
Upon receiving an interrupt signal the CPU:</p>
<ol>
<li>finishes execution of current instruction</li>
<li>Stores Program Counter and Status flag to the stack</li>
<li>Disables Interrupts by setting <strong>Disable Interrupt</strong> flag in the status register P</li>
<li>Loads the Address of Interrupt handler routine from 0xFFFA (for NMI)</li>
<li>Sets <strong>Program Counter</strong> register pointing to that address</li>
</ol>
<div style="text-align:center"><img src="./images/ch6.2/image_3_interrupt_mem.png" width="40%"/></div>
<p>Interrupt handler would have to call RTI operation at the end to finish interrupt attendance. That would restore Status Flag and Program Counter position from the stack. Effectively going back to the execution flow where it was left off. </p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>   fn interrupt_nmi(&amp;mut self) {
       self.stack_push_u16(self.program_counter);
       let mut flag = self.status.clone();
       flag.set(CpuFlags::BREAK, 0);
       flag.set(CpuFlags::BREAK2, 1);
 
       self.stack_push(flag.bits);
       self.status.insert(CpuFlags::INTERRUPT_DISABLE);
 
       self.bus.tick(2);
       self.program_counter = self.mem_read_u16(0xfffA);
   }
<span class="boring">}
</span></code></pre></pre>
<p>In addition to scanline position, PPU would immidiately trigger NMI if both of these conditions are met: </p>
<ul>
<li>PPU is VBLANK state</li>
<li>&quot;Generate NMI&quot; bit in the controll Register is updated from 0 to 1.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl PPU for NesPPU {
// ...    
    fn write_to_ctrl(&amp;mut self, value: u8) {
        let before_nmi_status = self.ctrl.generate_vblank_nmi();
        self.ctrl.update(value);
        if !before_nmi_status &amp;&amp; self.ctrl.generate_vblank_nmi() &amp;&amp; self.status.is_in_vblank() {
            self.nmi_interrupt = Some(1);
        }
    }
//..
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#other-cpu-interrupts" id="other-cpu-interrupts">Other CPU interrupts</a></h1>
<p>In our CPU implementation, we've implemented opcode <strong>0x00</strong> just as a return from CPU fetch-decode-execute cycle, but in reallity it should trigger BRK interrupt. This is so-called &quot;software interrupt&quot; that a game code can trigger programmatically in response to events.</p>
<p>NESDEV Wiki provides all neccessary details about <a href="https://wiki.nesdev.com/w/index.php/CPU_interrupts">CPU interrupts</a>. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch6.2" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#rendering-chr-rom-tiles" id="rendering-chr-rom-tiles">Rendering CHR ROM Tiles</a></h1>
<p>The address space <strong>[0x0 .. 0x2000]</strong> on PPU is reserved for CHR ROM - visual graphics data of a game. </p>
<p>That's <em>8 KiB</em> worth of data. And that's all there was in the first versions of NES cartridges. </p>
<p>Visual data is packed in so-called tiles: an 8 x 8 pixel image that could use up to 4 colors. (to be precise, background tile can have 4 colors, a sprite tile can have 3 colors, and 0b00 is used as an indication that a pixel should be transparent)</p>
<pre><code class="language-bash">8 * 8 * 2 (2 bits to codify color) = 128 bits  = 16 bytes to codify a single tile
</code></pre>
<p>8 KiB / 128 bits = 512 tiles. I.e., each cartridge contained 512 tiles in total, divided into 2 pages/banks. The banks did not really have a name, historically they are called &quot;left&quot; and &quot;right&quot;.</p>
<div style="text-align:center"><img src="./images/ch6.3/image_1_mario_tiles.png" width="50%"/></div>
<p>8 pixels x 8 pixels is a tiny size, not much can be presented that way. The majority of objects in NES games are composed of multiple tiles. </p>
<div style="text-align:center"><img src="./images/ch6.3/image_2_8bit_drawings.png" width="30%" ><br/> 8x8 pixel art by <a href="https://twitter.com/johanvinet">Johan Vinet</a> <br/><a href="https://twitter.com/PixelProspector/status/1097565152940044293">[Check it out]</a> </div>
<p>What makes the CHR format tricky is that tiles themselves don't have color information. Each pixel in a tile is codified using 2 bits, declaring a color index in a palette, not a color itself.</p>
<blockquote>
<p>If NES were using popular RGB format for each pixel, a single tile would occupy  8<em>8</em>24 = 192 bytes. And it would require 96 KiB of CHR ROM space to hold 512 tiles. </p>
</blockquote>
<p>The real color of a pixel is decided during the rendering phase by using the so-called color palette, more on this later.</p>
<p>By reading just CHR ROM, it is impossible to derive colors, only shapes. </p>
<div style="text-align:center"><img src="./images/ch6.3/image_3_chr_content.png" width="30%"/></div>
<div style="text-align:center"><img src="./images/ch6.3/image_4_color_code.png" width="50%"/></div>
<p>Surprisingly, 2 bits of a pixel are not codified in the same byte. A tile is described using 16 bytes. And each row is encoded using 2 bytes that stand 8 bytes apart from each other. 
To figure out the color index of the top-left pixel, we need to read the 7th bit of byte 0x0000 and the 7th bit of byte 0x0008, to get the next pixel in the same row we would need to read 6th bits in the same bytes, etc..</p>
<div style="text-align:center"><img src="./images/ch6.3/image_5_16bytes_of_a_tile.png" width="50%"/></div>
<h2><a class="header" href="#pallette" id="pallette">Pallette</a></h2>
<p>Before rendering CHR ROM content, we need to briefly discuss the colors available to the NES. 
Different versions of the PPU chip had slightly different system-level palettes of 52 hardwired colors. </p>
<p>All necessary details can be found on corresponding <a href="http://wiki.nesdev.com/w/index.php/PPU_palettes#Palettes">nesdev wiki page</a>.</p>
<div style="text-align:center"><img src="./images/ch6.3/image_6_system_palette.png" width="50%"/></div>
<p>There are multiple variations used in emulators. Some make the picture more visually appealing, while others keep it closer to the original picture NES generated on a TV. </p>
<p>It doesn't matter much which one we would choose, most of them get us good enough results.</p>
<p>However, we still need to codify that table in RGB format, that is recognized by SDL2 library:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[rustfmt::skip]
 
pub static SYSTEM_PALLETE: [(u8,u8,u8); 64] = [
   (0x80, 0x80, 0x80), (0x00, 0x3D, 0xA6), (0x00, 0x12, 0xB0), (0x44, 0x00, 0x96), (0xA1, 0x00, 0x5E),
   (0xC7, 0x00, 0x28), (0xBA, 0x06, 0x00), (0x8C, 0x17, 0x00), (0x5C, 0x2F, 0x00), (0x10, 0x45, 0x00),
   (0x05, 0x4A, 0x00), (0x00, 0x47, 0x2E), (0x00, 0x41, 0x66), (0x00, 0x00, 0x00), (0x05, 0x05, 0x05),
   (0x05, 0x05, 0x05), (0xC7, 0xC7, 0xC7), (0x00, 0x77, 0xFF), (0x21, 0x55, 0xFF), (0x82, 0x37, 0xFA),
   (0xEB, 0x2F, 0xB5), (0xFF, 0x29, 0x50), (0xFF, 0x22, 0x00), (0xD6, 0x32, 0x00), (0xC4, 0x62, 0x00),
   (0x35, 0x80, 0x00), (0x05, 0x8F, 0x00), (0x00, 0x8A, 0x55), (0x00, 0x99, 0xCC), (0x21, 0x21, 0x21),
   (0x09, 0x09, 0x09), (0x09, 0x09, 0x09), (0xFF, 0xFF, 0xFF), (0x0F, 0xD7, 0xFF), (0x69, 0xA2, 0xFF),
   (0xD4, 0x80, 0xFF), (0xFF, 0x45, 0xF3), (0xFF, 0x61, 0x8B), (0xFF, 0x88, 0x33), (0xFF, 0x9C, 0x12),
   (0xFA, 0xBC, 0x20), (0x9F, 0xE3, 0x0E), (0x2B, 0xF0, 0x35), (0x0C, 0xF0, 0xA4), (0x05, 0xFB, 0xFF),
   (0x5E, 0x5E, 0x5E), (0x0D, 0x0D, 0x0D), (0x0D, 0x0D, 0x0D), (0xFF, 0xFF, 0xFF), (0xA6, 0xFC, 0xFF),
   (0xB3, 0xEC, 0xFF), (0xDA, 0xAB, 0xEB), (0xFF, 0xA8, 0xF9), (0xFF, 0xAB, 0xB3), (0xFF, 0xD2, 0xB0),
   (0xFF, 0xEF, 0xA6), (0xFF, 0xF7, 0x9C), (0xD7, 0xE8, 0x95), (0xA6, 0xED, 0xAF), (0xA2, 0xF2, 0xDA),
   (0x99, 0xFF, 0xFC), (0xDD, 0xDD, 0xDD), (0x11, 0x11, 0x11), (0x11, 0x11, 0x11)
];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#rendering-chr-rom" id="rendering-chr-rom">Rendering CHR Rom</a></h2>
<p>To render tiles from a CHR ROM, we need to get a ROM file of a game. 
Google would help you find a lot of ROM dumps of the well-known classics. However, downloading such ROMs if you don't have a cartridge would be illegal (wink-wink).
There is a site that listed legit homebrew games that were recently developed. And some of them are pretty good, most of them are free.
Check it out: <a href="http://www.nesworld.com/article.php?system=nes&amp;data=neshomebrew">www.nesworld.com</a></p>
<p>The caveat here that our emulator supports only NES 1.0 format. And homebrew developed games tend to use NES 2.0. 
Games like &quot;Alter Ego&quot; would do. </p>
<p>I would use Pacman, mostly because it's recognizable, and I happen to own a cartridge of this game. </p>
<p>First, let's create an abstraction layer for a frame, so we wouldn't need to work with SDL directly:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Frame {
   pub data: Vec&lt;u8&gt;,
}
 
impl Frame {
   const WIDTH: usize = 256;
   const HIGHT: usize = 240;
 
   pub fn new() -&gt; Self {
       Frame {
           data: vec![0; (Frame::WIDTH) * (Frame::HIGHT) * 3],
       }
   }
 
   pub fn set_pixel(&amp;mut self, x: usize, y: usize, rgb: (u8, u8, u8)) {
       let base = y * 3 * Frame::WIDTH + x * 3;
       if base + 2 &lt; self.data.len() {
           self.data[base] = rgb.0;
           self.data[base + 1] = rgb.1;
           self.data[base + 2] = rgb.2;
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we are ready to render a tile on a frame:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn show_tile(chr_rom: &amp;Vec&lt;u8&gt;, bank: usize, tile_n: usize) -&gt;Frame {
   assert!(bank &lt;= 1);
 
   let mut frame = Frame::new();
   let bank = (bank * 0x1000) as usize;
  
   let tile = &amp;chr_rom[(bank + tile_n * 16)..=(bank + tile_n * 16 + 15)];
 
   for y in 0..=7 {
       let mut upper = tile[y];
       let mut lower = tile[y + 8];
 
       for x in (0..=7).rev() {
           let value = (1 &amp; upper) &lt;&lt; 1 | (1 &amp; lower);
           upper = upper &gt;&gt; 1;
           lower = lower &gt;&gt; 1;
           let rgb = match value {
               0 =&gt; palette::SYSTEM_PALLETE[0x01],
               1 =&gt; palette::SYSTEM_PALLETE[0x23],
               2 =&gt; palette::SYSTEM_PALLETE[0x27],
               3 =&gt; palette::SYSTEM_PALLETE[0x30],
               _ =&gt; panic!(&quot;can't be&quot;),
           };
           frame.set_pixel(x, y, rgb)
       }
   }
 
   frame
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> for now, we're interpreting color indices randomly. Just pick 4 random colors from the system palette for each index value to see how it would look like.</p>
</blockquote>
<p>Tying it all together in the main loop:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   // ….init sdl2
   // ....
 
   //load the game
   let bytes: Vec&lt;u8&gt; = std::fs::read(&quot;pacman.nes&quot;).unwrap();
   let rom = Rom::new(&amp;bytes).unwrap();
 
   let tile_frame = show_tile(&amp;rom.chr_rom, 1,0);
 
   texture.update(None, &amp;tile_frame.data, 256 * 3).unwrap();
   canvas.copy(&amp;texture, None, None).unwrap();
   canvas.present();
 
   loop {
      for event in event_pump.poll_iter() {
         match event {
           Event::Quit { .. }
           | Event::KeyDown {
               keycode: Some(Keycode::Escape),
               ..
           } =&gt; std::process::exit(0),
           _ =&gt; { /* do nothing */ }
         }
      }
 
   }
}
</code></pre></pre>
<p>And the result is not that impressive: </p>
<div style="text-align:center"><img src="./images/ch6.3/image_7_tile_1.png" width="50%"/></div>
<p>Might it be a Pacman's back..err.. head?  Who knows.</p>
<p>We can adjust code just a little bit to draw all tiles from CHR ROM:</p>
<div style="text-align:center"><img src="./images/ch6.3/image_8_pacman_chr_rom.png" width="80%"/></div>
<p>Aha! Despite colors being clearly off, the shapes are recognizable now—parts of ghosts, some letters, and numbers.
I guess that's it. Moving on</p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch6.3" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#rendering-static-screen" id="rendering-static-screen">Rendering Static Screen</a></h1>
<p>At this point, the CPU and PPU are fully functional and working in coordination with each other. 
So if we load a game into our emulator, the game would be executing and most likely would run into demo mode.</p>
<p>The problem is that we can't see what's going on inside. Remember how we had intercepted the execution of the snake game to read the game screen state? And then had it rendered via SDL2 canvas? We will have to do something similar here. It's just the data format used by NES is slightly more complicated.</p>
<p>PPU has to deal with 2 categories of objects:</p>
<div style="text-align:center"><img src="./images/ch6.4/image_8_bg_sprites_game.png" width="80%"/></div>
<p>Both of those are constructed using CHR tiles, we've discussed in the previous chapter. 
In fact, the same tile can be used both for background and for sprites. </p>
<p>But NES uses different memory spaces to hold those categories. Also, the set of possible transformations is different. </p>
<h2><a class="header" href="#rending-background" id="rending-background">Rending Background</a></h2>
<!-- <div style="text-align:center"><img src="./images/ch6.4/image_1_pacman_bg.png" width="30%"/></div> -->
<p>Three main memory sections are responsible for the state of a background:</p>
<ul>
<li>Pattern Table - one of 2 banks of tiles from CHR ROM </li>
<li>Nametable - the state of a screen stored in VRAM</li>
<li>Palette table - the information about the real coloring of pixels, stored in internal PPU memory</li>
</ul>
<p>NES Screen background screen is composed of 960 tiles (a tile being 8x8 pixels: <code>256 / 8 * 240 / 8  = 960</code>) 
Each tile is represented by one byte in VRAM in the space called Nametable. </p>
<div style="text-align:center"><img src="./images/ch6.4/image_2_nametable.png" width="100%"/></div>
<blockquote>
<p>Using a byte in nametable PPU can address only 256 elements within a single bank in pattern table.
Control register decides which of two banks should be used for background (and which one should be used for sprites)</p>
<div style="text-align:left"><img src="./images/ch6.4/image_3_control_register_highlight.png" width="50%"/></div>
</blockquote>
<p>In addition to 960 bytes for tiles, a nametable holds 64 bytes that specify color palette, we will discuss later. In total, a single frame is defined by 1024 bytes (960 + 64). PPU VRAM can simultaneously hold two nametables - state of two frames. </p>
<p>Two additional nametables that exist in the address space of the PPU must be either mapped to existing tables or to extra RAM space on a cartridge. 
More details: http://wiki.nesdev.com/w/index.php/Mirroring</p>
<p>Nametables are populated by CPU during program execution (using Addr and Data registers that we've implemented). It's entirely determined by game code. All we need to do is to read the correct part of the VRAM. </p>
<p>The algorithm to draw current background:</p>
<ol>
<li>Determine which nametable being used for the current screen (by reading bit 0 and bit 1 from Control register)</li>
<li>Determine which CHR ROM bank is used for background tiles (by reading bit 4 from Control Register)</li>
<li>Read 960 bytes from the specified nametable and draw a 32x30 tile-based screen </li>
</ol>
<p>Let's add <code>render</code> function to a new <code>render</code> module:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod frame;
pub mod palette;
 
use crate::ppu::NesPPU;
use frame::Frame;
 
pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {
   let bank = ppu.ctrl.bknd_pattern_addr();
 
   for i in 0..0x03c0 { // just for now, lets use the first nametable
       let tile = ppu.vram[i] as u16;
       let tile_x = i % 32;
       let tile_y = i / 32;
       let tile = &amp;ppu.chr_rom[(bank + tile * 16) as usize..=(bank + tile * 16 + 15) as usize];
 
       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];
 
           for x in (0..=7).rev() {
               let value = (1 &amp; upper) &lt;&lt; 1 | (1 &amp; lower);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; palette::SYSTEM_PALLETE[0x01],
                   1 =&gt; palette::SYSTEM_PALLETE[0x23],
                   2 =&gt; palette::SYSTEM_PALLETE[0x27],
                   3 =&gt; palette::SYSTEM_PALLETE[0x30],
                   _ =&gt; panic!(&quot;can't be&quot;),
               };
               frame.set_pixel(tile_x*8 + x, tile_y*8 + y, rgb)
           }
       }
   }
}

<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: We are still using randomly picked colors from a system palette just to see shapes</p>
</blockquote>
<p>Again we need to intercept the program execution to read the screen state. 
On the real console, PPU is drawing one pixel each PPU clock cycle. However, we can take a shortcut. Instead of reading part of the screen state on each PPU clock tick, we can wait until the full screen is ready and read in one go. </p>
<blockquote>
<p><strong>WARNING</strong> This is quite a drastic simplification that limits the types of games it will be possible to play on the emulator. </br><br/>More advanced games used a lot of tricks to enrich the gaming experience. 
For example, changing scroll in the middle of the frame (so-called <a href="https://wiki.nesdev.com/w/index.php/PPU_scrolling#Split_X_scroll">split scroll</a>) or changing palette colors. <br/><br/>
This simplification wouldn't affect first-gen NES games much. But the majority of NES games would require more accuracy in PPU emulation.</p>
</blockquote>
<p>On the real console, PPU is actively drawing screen state on a TV screen during 0 - 240 scanlines; during scanlines 241 - 262, the CPU is updating the state of PPU for the next frame, then the cycle repeats.</p>
<p>One way to intercept is to read the screen state right after NMI interrupt - when PPU is done rendering the current frame, but before CPU starts creating the next one.</p>
<p>First lets add callback to the bus, that will be called every time PPU triggers NMI:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>ub struct Bus&lt;'call&gt; {
   cpu_vram: [u8; 2048],
   prg_rom: Vec&lt;u8&gt;,
   ppu: NesPPU,
 
   cycles: usize,
   gameloop_callback: Box&lt;dyn FnMut(&amp;NesPPU) + 'call&gt;,
 
}
 
impl&lt;'a&gt; Bus&lt;'a&gt; {
   pub fn new&lt;'call, F&gt;(rom: Rom, gameloop_callback: F) -&gt; Bus&lt;'call&gt;
   where
       F: FnMut(&amp;NesPPU) + 'call,
   {
       let ppu = NesPPU::new(rom.chr_rom, rom.screen_mirroring);
 
       Bus {
           cpu_vram: [0; 2048],
           prg_rom: rom.prg_rom,
           ppu: ppu,
           cycles: 0,
           gameloop_callback: Box::from(gameloop_callback),
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then lets tweak <code>tick</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Bus&lt;'a&gt; {
//..
   pub fn tick(&amp;mut self, cycles: u8) {
        self.cycles += cycles as usize;

        let nmi_before = self.ppu.nmi_interrupt.is_some();
        self.ppu.tick(cycles *3);
        let nmi_after = self.ppu.nmi_interrupt.is_some();
        
        if !nmi_before &amp;&amp; nmi_after {
            (self.gameloop_callback)(&amp;self.ppu, &amp;mut self.joypad1);
        }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we can connect gameloop, interrupt callback and render function:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   // init sdl2…
 
   //load the game
   let bytes: Vec&lt;u8&gt; = std::fs::read(&quot;game.nes&quot;).unwrap();
   let rom = Rom::new(&amp;bytes).unwrap();
 
   let mut frame = Frame::new();
 
   // the game cycle
   let bus = Bus::new(rom, move |ppu: &amp;NesPPU| {
       render::render(ppu, &amp;mut frame);
       texture.update(None, &amp;frame.data, 256 * 3).unwrap();
 
       canvas.copy(&amp;texture, None, None).unwrap();
 
       canvas.present();
       for event in event_pump.poll_iter() {
           match event {
             Event::Quit { .. }
             | Event::KeyDown {
                 keycode: Some(Keycode::Escape),
                 ..
             } =&gt; std::process::exit(0),
             _ =&gt; { /* do nothing */ }
           }
        }
   });
 
   let mut cpu = CPU::new(bus);
 
   cpu.reset();
   cpu.run();
}
</code></pre></pre>
<p>It's working! Beau·ti·ful. </p>
<div style="text-align:center"><img src="./images/ch6.4/image_4_pacman_result.png" width="30%"/></div>
<p>Now let's fix the colors.</p>
<h2><a class="header" href="#working-with-colors" id="working-with-colors">Working with Colors</a></h2>
<p>NES Console could generate 52 different colors on a TV screen. Those colors constitute the hardwired System Palette of the console. </p>
<p>However, a single screen can use only 25 colors simultaneously: 13 background colors and 12 for sprites. </p>
<p>NES had internal memory RAM to store palette settings. 
The space is divided into 8 palettes tables: 4 for background and 4 for sprites. Each palette contains three colors. 
Remember that a pixel in a tile was coded using 2 bits - that's 4 possible values. 0b00 is a special one.</p>
<blockquote>
<p><strong>0b00</strong> for <em>background</em> tile means using Universal background color (stored at <strong>0x3F00</strong>). </p>
<p>For <em>sprites</em> - <strong>0b00</strong> means that the pixel is transparent</p>
</blockquote>
<div style="text-align:center"><img src="./images/ch6.4/image_5_palette_table.png" width="100%"/></div>
<p>A single tile can be drawn using only one palette from the palette table. 
For background tiles, the last 64 bytes of each nametable are reserved for assigning a specific palette to a part of the background. This section is called an attribute table.</p>
<p>A byte in an attribute table controls palettes for 4 neighboring meta-tiles. (a meta-tile is a space composed of 2x2 tiles)
To say it another way, 1 byte controls which palettes are used for 4x4 tile blocks or 32x32 pixels<br />
A byte is split into four 2bits blocks. And each block is assigning a background palette for four neighboring tiles. </p>
<div style="text-align:center"><img src="./images/ch6.4/image_6_attribute_table.png" width="70%"/></div>
<p>First let's extract palette for a background tile specified by its row and column position on a screen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn bg_pallette(ppu: &amp;NesPPU, tile_column: usize, tile_row : usize) -&gt; [u8;4] {
   let attr_table_idx = tile_row / 4 * 8 +  tile_column / 4;
   let attr_byte = ppu.vram[0x3c0 + attr_table_idx];  // note: still using hardcoded first nametable
 
   let pallet_idx = match (tile_column %4 / 2, tile_row % 4 / 2) {
       (0,0) =&gt; attr_byte &amp; 0b11,
       (1,0) =&gt; (attr_byte &gt;&gt; 2) &amp; 0b11,
       (0,1) =&gt; (attr_byte &gt;&gt; 4) &amp; 0b11,
       (1,1) =&gt; (attr_byte &gt;&gt; 6) &amp; 0b11,
       (_,_) =&gt; panic!(&quot;should not happen&quot;),
   };
 
   let pallete_start: usize = 1 + (pallet_idx as usize)*4;
   [ppu.palette_table[0], ppu.palette_table[pallete_start], ppu.palette_table[pallete_start+1], ppu.palette_table[pallete_start+2]]
}
<span class="boring">}
</span></code></pre></pre>
<p>And just rewire our color lookup in <code>render</code> function from using randomly picked colors to the actual ones:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {
   let bank = ppu.ctrl.bknd_pattern_addr();
 
   for i in 0..0x3c0 {
       let tile = ppu.vram[i] as u16;
       let tile_column = i % 32;
       let tile_row = i / 32;
       let tile = &amp;ppu.chr_rom[(bank + tile * 16) as usize..=(bank + tile * 16 + 15) as usize];
       let palette = bg_pallette(ppu, tile_column, tile_row);
 
       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];
 
           for x in (0..=7).rev() {
               let value = (1 &amp; lower) &lt;&lt; 1 | (1 &amp; upper);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; palette::SYSTEM_PALLETE[ppu.palette_table[0] as usize],
                   1 =&gt; palette::SYSTEM_PALLETE[palette[1] as usize],
                   2 =&gt; palette::SYSTEM_PALLETE[palette[2] as usize],
                   3 =&gt; palette::SYSTEM_PALLETE[palette[3] as usize],
                   _ =&gt; panic!(&quot;can't be&quot;),
               };
               frame.set_pixel(tile_column * 8 + x, tile_row * 8 + y, rgb)
           }
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>That's it.</p>
<h2><a class="header" href="#rendering-sprites" id="rendering-sprites">Rendering sprites.</a></h2>
<p>Rendering sprites is somewhat similar, yet a bit easier. 
NES had an internal RAM for storing states of all sprites in the frame, so-called Object Attribute Memory (OAM).</p>
<p>It had 256 bytes of RAM and reserved 4 bytes for each sprite. This gives an option of having 64 tiles on a screen simultaneously (but keep in mind that a single object on a screen usually consists of at least 3-4 tiles).</p>
<p>CPU has to option of updating OAM Table: </p>
<ul>
<li>using OAM Addr and OAM Data PPUT registers, updating one byte at a time. </li>
<li>bulk updating the whole table by transferring 256 bytes from CPU RAM using OAM DMA</li>
</ul>
<p>In comparison to background tiles, a sprite tile can be shown anywhere in a 256x240 screen. Each OAM record has 2 bytes reserved for X and Y coordinates, one byte is used to select a tile pattern from the pattern table. And the remaining byte specifies how the object should be drawn (for example, PPU can flip same tile horizontally or vertically)</p>
<p>NES Dev Wiki provides a pretty solid specification of <a href="http://wiki.nesdev.com/w/index.php/PPU_OAM">each byte in the OAM record</a></p>
<p>To render all visible sprites, we just need to scan through oam_data space and parse out every 4 bytes into a sprite:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {

//.. draw background
//draw sprites
   for i in (0..ppu.oam_data.len()).step_by(4).rev() {
       let tile_idx = ppu.oam_data[i + 1] as u16;
       let tile_x = ppu.oam_data[i + 3] as usize;
       let tile_y = ppu.oam_data[i] as usize;
 
       let flip_vertical = if ppu.oam_data[i + 2] &gt;&gt; 7 &amp; 1 == 1 {
           true
       } else {
           false
       };
       let flip_horizontal = if ppu.oam_data[i + 2] &gt;&gt; 6 &amp; 1 == 1 {
           true
       } else {
           false
       };
       let pallette_idx = ppu.oam_data[i + 2] &amp; 0b11;
       let sprite_palette = sprite_palette(ppu, pallette_idx);
      
       let bank: u16 = ppu.ctrl.sprt_pattern_addr();
 
       let tile = &amp;ppu.chr_rom[(bank + tile_idx * 16) as usize..=(bank + tile_idx * 16 + 15) as usize];
 
 
       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];
           'ololo: for x in (0..=7).rev() {
               let value = (1 &amp; lower) &lt;&lt; 1 | (1 &amp; upper);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; continue 'ololo, // skip coloring the pixel
                   1 =&gt; palette::SYSTEM_PALLETE[sprite_palette[1] as usize],
                   2 =&gt; palette::SYSTEM_PALLETE[sprite_palette[2] as usize],
                   3 =&gt; palette::SYSTEM_PALLETE[sprite_palette[3] as usize],
                   _ =&gt; panic!(&quot;can't be&quot;),
               };
               match (flip_horizontal, flip_vertical) {
                   (false, false) =&gt; frame.set_pixel(tile_x + x, tile_y + y, rgb),
                   (true, false) =&gt; frame.set_pixel(tile_x + 7 - x, tile_y + y, rgb),
                   (false, true) =&gt; frame.set_pixel(tile_x + x, tile_y + 7 - y, rgb),
                   (true, true) =&gt; frame.set_pixel(tile_x + 7 - x, tile_y + 7 - y, rgb),
               }
           }
       }
   }
<span class="boring">}
</span></code></pre></pre>
<p>The sprite palette lookup is very easy:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn sprite_palette(ppu: &amp;NesPPU, pallete_idx: u8) -&gt; [u8; 4] {
    let start = 0x11 + (pallete_idx * 4) as usize;
    [
        0,
        ppu.palette_table[start],
        ppu.palette_table[start + 1],
        ppu.palette_table[start + 2],
    ]
}
<span class="boring">}
</span></code></pre></pre>
<div style="text-align:center"><img src="./images/ch6.4/image_7_pacman_chrs.png" width="30%"/></div>
<p>Alright. Looks better now. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch6.4" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#emulating-joypads" id="emulating-joypads">Emulating joypads</a></h1>
<p>NES and Famicom supported a variety of controllers:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=UKMO5tlANEU">Joypads</a></li>
<li><a href="https://www.youtube.com/watch?v=ErzuU78v60M">Power pads</a></li>
<li><a href="https://www.youtube.com/watch?v=x6u3ek7BXps">Lightgun Zapper</a></li>
<li><a href="https://www.youtube.com/watch?v=u9k6xoErR4w">Arkanoid controller</a></li>
<li><a href="https://www.youtube.com/watch?v=j8J58aTxCPM">And even a keyboard</a></li>
</ul>
<p>We will emulate joypads as it's the most common one and the easiest device to emulate</p>
<div style="text-align:center;"><img src="./images/ch7/image_1_joypad2.png" width="40%"/></div>
<p>Two joypads are mapped to <strong>0x4016</strong> and <strong>0x4017</strong> CPU address space, respectively.
The same register can be used for both reading and writing. 
Reading from a controller reports the state of a button (1 - pressed, 0 - released). The controller reports a state of one button at a time. To get the state of all buttons, the CPU has to read the controller register 8 times. </p>
<p>The order of reported Buttons is as follows: </p>
<pre><code class="language-bash">A -&gt; B -&gt; Select -&gt; Start -&gt; Up -&gt; Down -&gt; Left -&gt; Right
</code></pre>
<p>After reporting the state of the button <strong>RIGHT</strong>, the controller would continually return 1s for all following read, until a strobe mode change.</p>
<p>The CPU can change the mode of a controller by writing a byte to the register. However, only the first bit matters. </p>
<p>Controller operates in 2 modes:</p>
<ul>
<li>strobe bit on - controller reports only status of the button A on every read</li>
<li>strobe bit off - controller cycles through all buttons</li>
</ul>
<p>So the most basic cycle to read the state of a joypad for CPU:</p>
<ol>
<li>Write <strong>0x1</strong> to <strong>0x4016</strong> (strobe mode on - to reset the pointer to button A)</li>
<li>Write <strong>0x00</strong> to <strong>0x4016</strong> (strobe mode off)</li>
<li>Read from <strong>0x4016</strong> eight times </li>
<li>Repeat</li>
</ol>
<p>Ok, so let's sketch it out. </p>
<p>We would need 1 byte to store the status of all buttons:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>bitflags! {
       // https://wiki.nesdev.com/w/index.php/Controller_reading_code
       pub struct JoypadButton: u8 {
           const RIGHT             = 0b10000000;
           const LEFT              = 0b01000000;
           const DOWN              = 0b00100000;
           const UP                = 0b00010000;
           const START             = 0b00001000;
           const SELECT            = 0b00000100;
           const BUTTON_B          = 0b00000010;
           const BUTTON_A          = 0b00000001;
       }
}
<span class="boring">}
</span></code></pre></pre>
<p>We need to track: </p>
<ul>
<li>strobe mode - on/off </li>
<li>the status of all buttons</li>
<li>an index of a button to be reported on the next read.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Joypad {
   strobe: bool,
   button_index: u8,
   button_status: JoypadButton,
}
 
impl Joypad {
   pub fn new() -&gt; Self {
       Joypad {
           strobe: false,
           button_index: 0,
           button_status: JoypadButton::from_bits_truncate(0),
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we can implement reading from and writing to a controller:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Joypad {
  //...
   pub fn write(&amp;mut self, data: u8) {
       self.strobe = data &amp; 1 == 1;
       if self.strobe {
           self.button_index = 0
       }
   }
 
   pub fn read(&amp;mut self) -&gt; u8 {
       if self.button_index &gt; 7 {
           return 1;
       }
       let response = (self.button_status.bits &amp; (1 &lt;&lt; self.button_index)) &gt;&gt; self.button_index;
       if !self.strobe &amp;&amp; self.button_index &lt;= 7 {
           self.button_index += 1;
       }
       response
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Don't forget to connect the Joypad to the BUS and map it for address 0x4016. </p>
<p>One last step is to adjust our game loop to update the status of the joypad depending of a keyboard button being pressed or released on the host machine:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   //... init sdl2
   //... load the game
   let mut key_map = HashMap::new();
   key_map.insert(Keycode::Down, joypad::JoypadButton::DOWN);
   key_map.insert(Keycode::Up, joypad::JoypadButton::UP);
   key_map.insert(Keycode::Right, joypad::JoypadButton::RIGHT);
   key_map.insert(Keycode::Left, joypad::JoypadButton::LEFT);
   key_map.insert(Keycode::Space, joypad::JoypadButton::SELECT);
   key_map.insert(Keycode::Return, joypad::JoypadButton::START);
   key_map.insert(Keycode::A, joypad::JoypadButton::BUTTON_A);
   key_map.insert(Keycode::S, joypad::JoypadButton::BUTTON_B);
 
 
   // run the game cycle
   let bus = Bus::new(rom, move |ppu: &amp;NesPPU, joypad: &amp;mut joypad::Joypad| {
       render::render(ppu, &amp;mut frame);
       texture.update(None, &amp;frame.data, 256 * 3).unwrap();
 
       canvas.copy(&amp;texture, None, None).unwrap();
 
       canvas.present();
       for event in event_pump.poll_iter() {
           match event {
               Event::Quit { .. }
               | Event::KeyDown {
                   keycode: Some(Keycode::Escape),
                   ..
               } =&gt; std::process::exit(0),
 
 
               Event::KeyDown { keycode, .. } =&gt; {
                   if let Some(key) = key_map.get(&amp;keycode.unwrap_or(Keycode::Ampersand)) {
                       joypad.set_button_pressed_status(*key, true);
                   }
               }
               Event::KeyUp { keycode, .. } =&gt; {
                   if let Some(key) = key_map.get(&amp;keycode.unwrap_or(Keycode::Ampersand)) {
                       joypad.set_button_pressed_status(*key, false);
                   }
               }
 
               _ =&gt; { /* do nothing */ }
           }
       }
   });
 
   //...
}
</code></pre></pre>
<p>And here we are. Now we can play NES classics, using a keyboard. If you want to have a little bit of geeky fun, I highly recommend buying USB replicas of original NES controllers on Amazon. </p>
<p>I'm not affiliated, I got <a href="https://www.amazon.com/gp/product/B07M7SYX11/ref=ppx_yo_dt_b_asin_title_o05_s00?ie=UTF8&amp;psc=1">these ones</a></p>
<p>SDL2 fully supports <a href="https://docs.rs/sdl2/0.34.2/sdl2/joystick/struct.Joystick.html">joysticks</a>, and with just a tiny adjustment in our game loop, we can have almost perfect NES experience. </p>
<div style="text-align:center;"><img src="./images/ch7/image_2_rl.png" width="40%"/></div>
<p>Ok, we've made quite a bit of progress here. Two major pieces left out are: </p>
<ul>
<li>Support for scrolling - we will enable gaming into platformers.</li>
<li>Audio Processing Unit - to get those sweet NES chiptunes back in our lives. </li>
</ul>
<div style="text-align:center;"><img src="./images/ch7/image_3_progress.png" width="80%"/></div>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch7" target="_blank">GitHub</a></p>
</blockquote>
<h1><a class="header" href="#ppu-scrolling" id="ppu-scrolling">PPU Scrolling</a></h1>
<p>Before we start discussing scrolling, we need to clarify one detail. We've discussed that PPU notifies the state of the frame by triggering NMI interrupt, which tells CPU that rendering of the current frame is finished. 
That's not the whole story. PPU has 2 additional mechanisms to tell its progress: </p>
<ul>
<li><a href="https://wiki.nesdev.com/w/index.php?title=PPU_OAM&amp;redirect=no#Sprite_zero_hits">sprite zero hit flag</a></li>
<li><a href="https://wiki.nesdev.com/w/index.php/PPU_sprite_evaluation#Sprite_overflow_bug">sprite overflow flag</a></li>
</ul>
<p>Both are reported using <a href="https://wiki.nesdev.com/w/index.php/PPU_registers#Status_.28.242002.29_.3C_read">PPU status register <strong>0x2002</strong></a></p>
<div style="text-align:center;"><img src="./images/ch8/image_7_sprite_0_hit.png" width="60%"/></div>
<p>Sprite overflow is rarely used because it had a bug that resulted in false positives and false negatives. 
Sprite 0 hit though is used by the majority of games that have scrolling. <br/>It's the way to get mid-frame progress status
of PPU:</p>
<ul>
<li>put sprite zero on a specific screen location (X, Y)</li>
<li>poll status register</li>
<li>when sprite_zero_hit changes from 0 to 1 - CPU knows that PPU has finished rendering <strong>[0 .. Y]</strong> scanlines, and on the Y scanline, it's done rendering X pixels.</li>
</ul>
<blockquote>
<p>This is a very rough simulation of the behavior. The accurate one requires checking opaque pixels of a sprite colliding with opaque pixels of background.</p>
</blockquote>
<p>We need to codify this behavior in PPU <code>tick</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn tick(&amp;mut self, cycles: u8) -&gt; bool {
        self.cycles += cycles as usize;
        if self.cycles &gt;= 341 {
            if self.is_sprite_0_hit(self.cycles) {
                self.status.set_sprite_zero_hit(true);
            }

            self.cycles = self.cycles - 341;
            self.scanline += 1;

            if self.scanline == 241 {
                self.status.set_vblank_status(true);
                self.status.set_sprite_zero_hit(false);
                if self.ctrl.generate_vblank_nmi() {
                    self.nmi_interrupt = Some(1);
                }
            }

            if self.scanline &gt;= 262 {
                self.scanline = 0;
                self.nmi_interrupt = None;
                self.status.set_sprite_zero_hit(false);
                self.status.reset_vblank_status();
                return true;
            }
        }
        return false;
    }

    fn is_sprite_0_hit(&amp;self, cycle: usize) -&gt; bool {
        let y = self.oam_data[0] as usize;
        let x = self.oam_data[3] as usize;
        (y == self.scanline as usize) &amp;&amp; x &lt;= cycle &amp;&amp; self.mask.show_sprites()
    }

<span class="boring">}
</span></code></pre></pre>
<p>Note: the sprite zero hit flag should be erased upon entering VBLANK state.</p>
<h2><a class="header" href="#scrolling" id="scrolling">Scrolling</a></h2>
<p>The scroll is one of the primary mechanisms to simulate movement in space in NES games. It's an old idea of moving the viewport against the static background to create an illusion of movement through space.</p>
<div style="text-align:center;"><img src="./images/ch8/image_1_scroll_basics.png" width="80%"/></div>
<p>The scroll is implemented on the PPU level and only affects the rendering of background tiles (those stored in nametables). Sprites (OAM data) are not affected by this.</p>
<p>PPU can keep two screens in memory simultaneously (remember one name table - 1024 bytes, and PPU has 2 KiB of VRAM). This doesn't look like a lot, but this is enough to do the trick. During the scroll the viewport cycles through those two nametables, while the CPU is busy updating the part of the screen that's not yet visible, but will be soon. 
That also means that most of the time, the PPU is rendering parts of both nametables. </p>
<p>Because this exhausts all available console resources, early games had only 2 options for scrolling: horizontal or vertical. Old games were settled on the type of scroll for the whole game. 
Games that came later on had a mechanism to alternate scrolling between stages. And the most advanced games (like Zelda) provided the experience where a user can &quot;move&quot; in all 4 directions. </p>
<div style="text-align:center;"><img src="./images/ch8/image_2_scroll_mirroring.png" width="60%"/></div>
<p>Initially, the scroll was tightly coupled with mirroring - mostly because of the way NES handled overflow of a viewport from one nametable to another on hardware level. </p>
<p>For games like Super Mario Bros (Horizontal Scroll) or Ice Climber (Vertical Scroll), the mechanism is entirely defined by:</p>
<ul>
<li>Mirroring type (set in a cartridge ROM header)</li>
<li>Base Nametable address (value in PPU Control register)</li>
<li>Status of PPU Scroll Register (X and Y shift values of the viewport, in pixels)</li>
<li>Content of Nametables</li>
</ul>
<p>Remember, a background screen is defined by 960 tiles, each tile being 8x8 pixels, because PPU Scroll Register defines shifts in pixels, which means that on edges of the viewport, we can see parts of a tile.</p>
<div style="text-align:center;"><img src="./images/ch8/image_3_scroll_controll.png" width="70%"/></div>
<p>Updating PPU memory is relatively expensive, and the CPU can do this only during 241 - 262 scanlines. Because of these constraints, the CPU can update a relatively thin part (2x30 tiles wide area) of a screen per frame. 
If we render parts of the nametables that are not yet visible, we can see how the state of the world comes into existence a couple frames before entering the viewport. </p>
<div style="text-align:center;"><img src="./images/ch8/image_4_scroll_demo.gif" width="50%"/></div>
<p>2 last notes before jumping into implementation:</p>
<ul>
<li>The palette of a tile is defined by the nametable the tile belongs to, <strong>not</strong> by the base nametable specified in the Control register</li>
<li>For horizontal scrolling the content of the base nametable always goes to the left part of the viewport (or top part in case of vertical scrolling)</li>
</ul>
<div style="text-align:center;"><img src="./images/ch8/image_5_scroll_caveats.png" width="80%"/></div>
<p>Implementing scroll rendering is not hard but requires attention to details. The most convenient mental model I could come up with is the following:</p>
<ul>
<li>For each frame, we would scan through both nametables.</li>
<li>For each nametable we would specify visible part of the nametable:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Rect {
   x1: usize,
   y1: usize,
   x2: usize,
   y2: usize,
}
 
impl Rect {
   fn new(x1: usize, y1: usize, x2: usize, y2: usize) -&gt; Self {
       Rect {
           x1: x1,
           y1: y1,
           x2: x2,
           y2: y2,
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>And apply shift transformation for each visible pixel - shift_x, shift_y</li>
</ul>
<blockquote>
<p>For example,</p>
<div style="text-align:center;"><img src="./images/ch8/image_6_transform_example.png" width="30%"/></div>
<p>For nametable <strong>0x2400</strong>: the visible area would be defined as <strong>(200, 0, 256, 240)</strong> and the shift would be <strong>(-200, 0)</strong><br/>
For nametable <strong>0x2000</strong>: the visible area is <strong>(0,0, 200, 240)</strong> and the shift is <strong>(56, 0)</strong></p>
</blockquote>
<p>So, to draw a nametable we need to create a helper function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn render_name_table(ppu: &amp;NesPPU, frame: &amp;mut Frame, name_table: &amp;[u8],
   view_port: Rect, shift_x: isize, shift_y: isize) {
   let bank = ppu.ctrl.bknd_pattern_addr();
 
   let attribute_table = &amp;name_table[0x3c0.. 0x400];
 
   for i in 0..0x3c0 {
       let tile_column = i % 32;
       let tile_row = i / 32;
       let tile_idx = name_table[i] as u16;
       let tile = &amp;ppu.chr_rom[(bank + tile_idx * 16) as usize..=(bank + tile_idx * 16 + 15) as usize];
       let palette = bg_pallette(ppu, attribute_table, tile_column, tile_row);
 
       for y in 0..=7 {
           let mut upper = tile[y];
           let mut lower = tile[y + 8];
 
           for x in (0..=7).rev() {
               let value = (1 &amp; lower) &lt;&lt; 1 | (1 &amp; upper);
               upper = upper &gt;&gt; 1;
               lower = lower &gt;&gt; 1;
               let rgb = match value {
                   0 =&gt; palette::SYSTEM_PALLETE[ppu.palette_table[0] as usize],
                   1 =&gt; palette::SYSTEM_PALLETE[palette[1] as usize],
                   2 =&gt; palette::SYSTEM_PALLETE[palette[2] as usize],
                   3 =&gt; palette::SYSTEM_PALLETE[palette[3] as usize],
                   _ =&gt; panic!(&quot;can't be&quot;),
               };
               let pixel_x = tile_column * 8 + x;
               let pixel_y = tile_row * 8 + y;
 
               if pixel_x &gt;= view_port.x1 &amp;&amp; pixel_x &lt; view_port.x2 &amp;&amp; pixel_y &gt;= view_port.y1 &amp;&amp; pixel_y &lt; view_port.y2 {
                   frame.set_pixel((shift_x + pixel_x as isize) as usize, (shift_y + pixel_y as isize) as usize, rgb);
               }
           }
       }
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then rendering background becomes relatively simple:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>pub fn render(ppu: &amp;NesPPU, frame: &amp;mut Frame) {
   let scroll_x = (ppu.scroll.scroll_x) as usize;
   let scroll_y = (ppu.scroll.scroll_y) as usize;
 
   let (main_nametable, second_nametable) = match (&amp;ppu.mirroring, ppu.ctrl.nametable_addr()) {
       (Mirroring::VERTICAL, 0x2000) | (Mirroring::VERTICAL, 0x2800) =&gt; {
           (&amp;ppu.vram[0..0x400], &amp;ppu.vram[0x400..0x800])
       }
       (Mirroring::VERTICAL, 0x2400) | (Mirroring::VERTICAL, 0x2C00) =&gt; {
           ( &amp;ppu.vram[0x400..0x800], &amp;ppu.vram[0..0x400])
       }
       (_,_) =&gt; {
           panic!(&quot;Not supported mirroring type {:?}&quot;, ppu.mirroring);
       }
   };
 
   render_name_table(ppu, frame,
       main_nametable,
       Rect::new(scroll_x, scroll_y, 256, 240 ),
       -(scroll_x as isize), -(scroll_y as isize)
   );

    render_name_table(ppu, frame,
        second_nametable,
        Rect::new(0, 0, scroll_x, 240),
        (256 - scroll_x) as isize, 0
    );
   
// … render sprites
}

<span class="boring">}
</span></code></pre></pre>
<p>Implementing the vertical scroll is similar; we could reuse the same <code>render_name_table</code> helper function without changes. Just need to figure out proper <em>addressing</em>, <em>shifts</em>, and <em>view_port</em> parameters.</p>
<p>The fully defined code for scrolling can be found <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch8">here</a></p>
<p>Support for scrolling means that now we can play old platformers like Super Mario Bros and Ice Climber.</p>
<p>The final missing piece is APU. </p>
<br/>
<hr />
<blockquote>
<p>The full source code for this chapter: <a href="https://github.com/bugzmanov/nes_ebook/tree/master/code/ch8" target="_blank">GitHub</a></p>
</blockquote>
<p><br/> <br/> <br/> <br/></p>
<div style="text-align:center;"><img src="./images/ch9/image_1_coming_soon_3.png" width="30%"/></div>
<h1><a class="header" href="#afterword" id="afterword">Afterword</a></h1>
<style type="text/css">
    @media screen and (min-width: 651px) {
        #full-screen { display: block }
        #mobile { display: none }
    }

    @media screen and (max-width: 650px) {
        #full-screen { display: none }
        #mobile { display: block }
    }
</style>
<div id="full-screen" >
<table style="width:100%; border: none;"> 
<tr>
<td style="width:50%; border: none; padding: 0; ">Hey there! I’m Rafael Bagmanov, software developer from NYC. <br/>I write in Scala, Rust and Clojure. I usually work on data-crunching software in the coal mines of backend engineering. <br/><br/>And I’m a big fan of distributed systems, data-intensive apps, and functional programming. 
<p>You can find more about me on:</p>
<ul>
<li><a href="https://twitter.com/bugzmanov">Twitter</a> </li>
<li><a href="https://github.com/bugzmanov/">Github</a></li>
<li><a href="https://www.linkedin.com/in/bugzmanov/">LinkedIn</a></li>
</ul>
</td>
<td style="widht:50%; border: none; padding: 0;"> <img src="./images/afterwords/image_2_reviews_bw.png" width="100%"/></td>
</tr>
</table>
<table style="width:100%"> 
<tr>
<td style="width:40%; border: none;"> <br/><img src="./images/afterwords/image_1_bye.png" width="100%"/> </td>
<td style="widht:70%; border: none;"> <br/> I hope you've enjoyed the read and had a great time. <br/> Emulating old hardware is so much fun. Those systems were designed to be read, understood and modified by humans. And despite being very low-level, you don't need ten layers of abstraction to get it and see it working. And that's amazing.<br/><br/>Until next time!</td>
</tr>
</table>
</div>
<div id="mobile">
Hey there! I’m Rafael Bagmanov, software developer from NYC. <br/>I write in Scala, Rust, and Clojure. I usually work on data-crunching software in the coal mines of backend engineering. <br/><br/>And I’m a big fan of distributed systems, data-intensive apps, and functional programming. 
<p>You can find more about me on:</p>
<ul>
<li><a href="https://twitter.com/bugzmanov">Twitter</a> </li>
<li><a href="https://github.com/bugzmanov/">GitHub</a></li>
<li><a href="https://www.linkedin.com/in/bugzmanov/">LinkedIn</a></li>
</ul>
<div style="text-align:center"><img src="./images/afterwords/image_2_reviews_bw.png" width="80%"/></div>
<p>I hope you've enjoyed the read and had a great time. <br/> Emulating old hardware is so much fun. Those systems were designed to be read, understood, and modified by humans. And despite being very low-level, you don't need ten layers of abstraction to get it and see it working. And that's amazing.<br/><br/>Until next time!</p>
<div style="text-align:center"><img src="./images/afterwords/image_1_bye.png" width="80%"/></div>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-3286054-2', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
